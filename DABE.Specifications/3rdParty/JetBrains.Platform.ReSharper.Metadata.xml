<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.ReSharper.Metadata</name>
    </assembly>
    <members>
        <member name="F:JetBrains.Metadata.Access.CorFileFlags.ffContainsMetaData">
            <summary>
            Indicates that the file is not a resource file
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.CorFileFlags.ffContainsNoMetaData">
            <summary>
            Indicates that the file, possibly a resource file, does not contain metadata
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.FusionMetadataProvider">
            <summary>
            Provides metadata interface for various sources (Fusion variant)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataProvider.DisposeMetadataAccess(JetBrains.Metadata.Access.IMetadataAccess)">
            <summary>
            You must call DisposeMetadataAccess after every GetFrom* method,
            but if you're loading assemblies via MetadataLoader that will be done for you automatically
            on loader dispose
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ILReaderMetadataProvider">
            <summary>
            Provides metadata interface for various sources (ILReader version, only managed code)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.TypeDefProperties">
            <summary>
            Structure for storing typedef properties
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.Name">
            <summary>
            Gets fully qualified type name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.BaseToken">
            <summary>
            Gets base token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.TypeDefFlags">
            <summary>
            Gets typedef flags
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.TypeRefProperties">
            <summary>
            Structure for storing typeref properties
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.ResolutionScope">
            <summary>
            Gets type reference resolution scope
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.Name">
            <summary>
            Gets references type name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParamProperties.Name">
            <summary>
            Gets name of generic parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParamProperties.ParamIndex">
            <summary>
            Gets generic parmeter index
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParamProperties.OwnerToken">
            <summary>
            Gets owner token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParamProperties.GenericParamAttributes">
            <summary>
            Gets generic param attributes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParamProperties.Constraints">
            <summary>
            Gets generic param constraints
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.MemberReferenceProperties">
            <summary>
            Stores properties of a member reference
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.IMetadataAccess">
            <summary>
            Interface for accessing metadata in abstract way
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetAssemblyInfo">
            <summary>
            Gets assembly info interface if available
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetModuleRefs">
            <summary>
            Gets array of all available module references
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeDefs">
            <summary>
            Gets array of all available typedef tokens
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeDefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a typedef
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeRefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a typeref
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeSpecBlob(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for typeSpec
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetStandaloneSignatureBlob(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for StandAloneSig
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodSpecProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for typeSpec
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindMethodSpecs(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Find all MethodSpec records for concrete method def or ref
            </summary>
            <param name="methodDefOrRef">MethodDefOrRef token</param>
            <returns>Array of corresponding MethodSpec tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetGenericParameters(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of generic parameters fot the specified owner
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetGenericParamProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a generic parameter
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetInterfaceImplementations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of implemented interfaces tokens for specified type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMemberName(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets member (field, method, event or property) name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetFields(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type fields
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetFieldProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets field properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethods(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type methods
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameters(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method parameters
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameterByIndex(JetBrains.Metadata.Access.MetadataToken,System.UInt32)">
            <summary>
            Gets parameter by its index in method signature
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameterProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets parameter properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetPropertyProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets property properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEvents(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type events
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEventProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets event properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEnclosingType(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets enclosing type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributes(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of custom attributes attached to the specified entity
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributeProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets custom attribute properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributeTypeName(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets custom attribute type fully qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetModuleRefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a module reference
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMemberReferenceProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a member reference
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodImplementationProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method implementation map for a type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetPInvokeProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets PInvoke dispatch information for method 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMarshalSpec(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets marshalling specification for field or parameter if available, null if not
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeRefs">
            <summary>
            Gets array of type references from the assembly
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetClassLayout(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets class layout if specified, null if not
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetUserstring(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets the string from userstring heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetSecurityProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets security attributes from HasDeclSecurity token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindTypeRef(JetBrains.Metadata.Access.MetadataToken,System.String)">
            <summary>
            Finds a record in TypeRef table
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeSpecs">
            <summary>
            Enumerates all TypeSpec records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindMemberRefs(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Finds all MemberRefs owned by type <paramref name="typeToken"/>
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.MetadataProvider">
            <summary>
            Metadata provider used to create metadata access
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.Mvid">
            <summary>
            Gets unique MVID
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.NestedTypeMap">
            <summary>
            Nested-relation between types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.TypeName2TokenMapping">
            <summary>
            Mapping between qualified type names and their typedef tokens
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperty.Token">
            <summary>
            Exported type token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperty.ClrName">
            <summary>
            The name of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperty.Implemetation">
            <summary>
            An mdFile, mdAssemblyRef, or mdExportedType metadata token that contains or allows access to the properties of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperty.TypeDef">
            <summary>
            mdTypeDef token that represents a type in the file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperty.ExportedTypeFlags">
            <summary>
            flags that describe the metadata applied to the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.Name">
            <summary>
            The simple name of the file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.Token">
            <summary>
            Token of file reference
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.FileFlags">
            <summary>
            flags that describe the metadata applied to a file
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.IMetadataAssemblyInfo">
            <summary>
            Provides access to assembly metadata info
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetAssemblyName">
            <summary>
            Gets full assembly name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetReferencedAssembliesNames">
            <summary>
            Gets names of referenced assemblies
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetExportedTypes">
            <summary>
            Get the exported types table
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetReferencedFiles">
            <summary>
            files referenced in the current assembly manifest
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetToken">
            <summary>
            Gets assembly token
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.EncodedTokenType">
            <summary>
            Type of the encoded token in the CIL tables
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ITableReader">
            <summary>
            Metadata tables reader 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadString">
            <summary>
            Read index to the #Strings heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadGuid">
            <summary>
            Read index to the #GUID heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadBlob">
            <summary>
            Read index to the #Blob heap
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess">
            <summary>
            PE file metadata reader
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.TableManager.CODED_TOKEN_BITS">
            <summary>
            Contains number of bits to represent coded token.
            Indexed by number of possible values in given coded token type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.TableManager.TableReader.ReadCodedToken(JetBrains.Metadata.Access.ILReader.EncodedTokenType)">
            <summary>
            Read coded (multi targeting) token
            </summary>
            <param name="type">Set of the token targets</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataProviderFactory">
            <summary>
            Provides metadata interface for various sources
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataTableId">
            <summary>
            Metadata tables
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.Prologs">
            <summary>
            Enumerates prologs for different signatures
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataToken">
            <summary>
            Represents metadata token
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ExceptionHandler">
            <summary>
            MSIL exception handler record
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ExceptionHandlerType">
            <summary>
            Exception handler type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.FlowControl">
            <summary>
             IL Code FlowControl enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ILMethodFlags">
            <summary>
            IL method body flags
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.SmallCode">
            <summary>
            Small Code 
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.TinyCode">
            <summary>
            Tiny code format
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.FatCode">
            <summary>
            Fat code format
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.CodeMask">
            <summary>
            Mask for extract code type
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.InitLocals">
            <summary>
            Runtime call default constructor on all local vars
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.MoreSects">
            <summary>
            there is another attribute after this one
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.Instruction">
            <summary>
            MSIL instruction
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Offset">
            <summary>
            Instruction offset from the method begin
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Code">
            <summary>
            Instruction Code
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ILMethodBody">
            <summary>
            MSIL Method body
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.Opcode">
            <summary>
            MSIL opcode value
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.Opcodes">
            <summary>
             OpCodes static definitions
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OpCodeType">
            <summary>
             OpCodeType enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OpcodeValues">
            <summary>
             Operation codes enumeration
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Break">
            <summary>
            Debugging breakpoint
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Br_s">
            <summary>
            The short-parameter form of br.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Brfalse_s">
            <summary>
            Branch if {value} is zero.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Brtrue_s">
            <summary>
            Branch if {value} is nonzero
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Beq_s">
            <summary>
            Branch if {value1} is equal to {value2}.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValues.Bne_un_s">
            <summary>
            Branch if the two values are not equal. Integer values are interpreted as unsigned
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OperandType">
            <summary>
             OperandsType enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.StackBehaviour">
            <summary>
             StackBehaviour enumeration
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.CloseEnum(System.UIntPtr)">
            <summary>Close an enumeration of elements in the metadata</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.CountEnum(System.UIntPtr,System.Int32@)">
            <summary>Count the number of items available in an enumerations</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
            <param name="count">An output parameter which is filled with the item count</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.ResetEnum(System.UIntPtr,System.UInt32)">
            <summary>Reset an enumeration to a specific position</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
            <param name="ulPos">The item position to reset to</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
             <summary>Tokens representing typedefs from an enumeration of typedefs in the metadata scope</summary>
             <example>
             <code>
              int hEnum=0;
              int[] toks=new int[5];
              int enumCount;
              try {
                impScope.EnumTypeDefs(ref hEnum,toks,toks.Length,out enumCount);
                char[] nameBuffer=new char[2048];
                int nameLen=0;
                int superType=0;
                int typeFlags=0;
                int global=0;
                while(enumCount&gt;0) {
                  for(int I=0;I&lt;enumCount;I++) { 
                    Console.Error.Write(toks[I].ToString("X8"));
                    impScope.GetTypeDefProps(toks[I],nameBuffer,nameBuffer.Length,out nameLen,out typeFlags,out superType);
                    impScope.IsGlobal(toks[I],out global);
                    Console.Error.WriteLine(" "+new String(nameBuffer,0,nameLen)+" "+typeFlags.ToString("X8")+" "+superType.ToString("X8")+" "+global);
                    }
            
                  impScope.EnumTypeDefs(ref hEnum,toks,toks.Length,out enumCount);
                  }
                } 
              finally {
                if(hEnum!=0) impScope.CloseEnum(hEnum);
                }
             </code>
             </example>
             <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
             <param name="rTypeDefs">An array into which the typedefs are returned</param>
             <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
             <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
             <returns>The HRESULT from the COM method</returns>
             <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)"/>
             <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeRefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Tokens representing interface implementations from an enumeration in the metadata scope</summary>
            <example><see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></example>
            <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
            <param name="td">Token specifying the TypeDef whose InterfaceImpls are required</param>
            <param name="rTypeDefs">An array into which the typedefs are returned</param>
            <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
            <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
            <returns>The HRESULT from the COM method</returns>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeRefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeRefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate tokens represention type references from an enumeration in the metadata scope</summary>
            <example><see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></example>
            <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
            <param name="rTypeDefs">An array into which the typedefs are returned</param>
            <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
            <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
            <returns>The HRESULT from the COM method</returns>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)"/>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindTypeDefByName(System.String,System.UInt32,System.UInt32@)">
            <summary>Find a typedef token by the name of the type</summary>
            <param name="szTypeDef">The name of the type</param>
            <param name="tkEnclosingClass">The enclosing class for the type or 0 (token_null)</param>
            <param name="ptd">The output parameter into which the typedef token will be written</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetScopeProps(System.Char[],System.Int32,System.Int32@,System.Guid@)">
            <summary>Get some properties from the scope - these are the module name and the module MVID unique GUID</summary>
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <param name="mvid">Guid into which the MVID is written</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetModuleFromScope(System.UInt32@)">
            <summary>Get the metadata token for the module on which this scope was opened</summary>
            <param name="pmd">The output parameter into which the module token is written</param>
            <returns>The HRESULT from the COM method</returns>      
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetTypeDefProps(System.UInt32,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.UInt32@)">
            <summary>Get the name, flags and base class of a typedef (if appropriate)</summary>
            <param name="td">Token to retrieve the properties from</param>
            <param name="szTypeDef">Char buffer into which the name will be written</param>
            <param name="cchTypeDef">Size of the buffer <paramref name="szTypeDef"/></param>
            <param name="pchTypeDef">Output parameter for the actual number of characters written into the buffer <paramref name="szTypeDef"/></param>      
            <param name="pdwTypeDefFlags">Outpu parameter for the flags from this typedef</param>
            <param name="ptkExtends">Output parameter for the base type token</param>
            <returns>The HRESULT from the COM method</returns>      
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetInterfaceImplProps(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>Get the interface implementation details</summary>
            <param name="iiImpl">Interface implementation instance token from <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="pClass">Output class token implementing interface</param>
            <param name="ptkIface">Output interface token implemented by class</param>
            <returns>The HRESULT from the COM method</returns>      
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetTypeRefProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@)">
            <summary>Get the properties from a typeref</summary>
            <param name="tr">The typeref token to retrieve details from</param>
            <param name="ptkResolutionScope">Output token for the resolution scope, either a moduleref or an assemblyref</param>
            <param name="szName">Char buffer into which the name will be written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter for the actual number of characters written into the buffer <paramref name="szName"/></param>      
            <returns>The HRESULT from the COM method</returns>         
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.ResolveTypeRef(System.UInt32,System.Guid@,System.Object@,System.UInt32@)">
            <summary>Return the scope and token for a typedef corresponding to a (possibly imported) typeref</summary>
            <param name="tr">Typeref to resolve</param>
            <param name="riid">Interface type GUID for the returned interface, normally IID_IMetadataImport</param>
            <param name="ppIScope">Output object which may be cast to the interface type specified in <paramref name="riid"/></param>
            <param name="ptd">Output parameter into which the typedef token in the scope <paramref name="ppIScope"/> is written</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMembers(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the members of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMembersWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the members of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMethods(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the methods of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMethodsWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the methods of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumFields(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the fields of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumFieldsWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the fields of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumParams(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the parameters of a methods</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMemberRefs(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Retrieve all of the member refs for a specified type within the scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="cl">Token to enumerate members from. Use 0 (token_null) for globals</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMethodImpls(System.UIntPtr@,System.UInt32,System.UInt32[],System.UInt32[],System.Int32,System.Int32@)">
            <summary>Retrieve all of the methods implementation details</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="td">Typedef to enumerate methods implementations from</param>
            <param name="rMethodBody">Array into which the method body tokens are written</param>
            <param name="rMethodDecl">Array into which the method interface declaration tokens are written</param>
            <param name="cMax">Size of the arrays <paramref name="rMethodBody"/> and <paramref name="rMethodDecl"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMethodBody"/> and <paramref name="rMethodDecl"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumPermissionSets(System.UIntPtr@,System.UInt32,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Retrieve all of the permission sets for a specified type within the scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="tk">Token to enumerate members from</param>
            <param name="dwActions">Mask of actions to return if non-zero</param>
            <param name="rPermission">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rPermission"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rPermission"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindMember(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a member by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindMethod(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a method by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindField(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a field by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindMemberRef(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a memberref by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetMethodProps(System.UInt32,System.UInt32@,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@)">
            <summary>Retrieve the method detail for a method token</summary>
            <param name="mb">The method token to retrieve properties from</param>
            <param name="pClass">The output parameter for the token representing the class owning this method token</param>
            <param name="szMethod">Char array into which the method name is written</param>
            <param name="cchMethod">Size of the array <paramref name="szMethod"/></param>param>
            <param name="pchMethod">Actual count written into the array <paramref name="szMethod"/></param>
            <param name="pdwAttr">Output parameter for the method flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pulCodeRVA">Output parameter for relative virtual address in the assembly of the method's code</param>
            <param name="pdwImplFlags">Output parameter for the method implementation flags</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetMemberRefProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.IntPtr@,System.Int32@)">
            <summary>Retrieve the member detail for a memberref token</summary>
            <param name="mr">The memberref token to retrieve properties from</param>
            <param name="ptk">The output parameter for the token representing the class def or ref owning this member token</param>
            <param name="szMember">Char array into which the member name is written</param>
            <param name="cchMember">Size of the array <paramref name="szMember"/></param>param>
            <param name="pchMember">Actual count written into the array <paramref name="szMember"/></param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <returns>The HRESULT from the COM member</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumProperties(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the properties on a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="td">Token to enumerate properties from</param>
            <param name="rProperties">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rProperties"/></param>
            <param name="pcProperties">Output parameter for the actual count of tokens written into <paramref name="rProperties"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumEvents(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the events on a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="td">Token to enumerate events from</param>
            <param name="rEvents">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rEvents"/></param>
            <param name="pcEvents">Output parameter for the actual count of tokens written into <paramref name="rEvents"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetEventProps(System.UInt32,System.UInt32@,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Get the detail for an event</summary>
            <param name="ev">Event token</param>
            <param name="pClass">Type in which event is defined</param>
            <param name="szEvent">Char buffer into which event name is written</param>
            <param name="cchEvent">Buffer size of <paramref name="szEvent"/></param>
            <param name="pchEvent">Output parameter for the actual number of characters written into <paramref name="szEvent"/></param>
            <param name="pdwEventFlags">Output parameter for the event flags</param>
            <param name="ptkEventType">Output parameter for the event typeref token</param> 
            <param name="pmdAddOn">Output parameter for the add method token</param>
            <param name="pmdRemoveOn">Output parameter for the remove method token</param>
            <param name="pmdFire">Output parameter for the fire method token</param>
            <param name="rmdOtherMethod">Array into which other methods tokens associated with this event are written</param>
            <param name="cMax">Size of the <paramref name="rmdOtherMethod"/> array</param>
            <param name="pcOtherMethod">Output parameter for the actual count written into the <paramref name="rmdOtherMethod"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumMethodSemantics(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Return extended method semantics information</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="mb">Methoddef token for method of interest</param>
            <param name="rEventProp">Array into which event or property with which this method is associated is written</param>
            <param name="cMax">Size of the <paramref name="rEventProp"/> array</param>
            <param name="pcEventProp">Output parameter for the actual count written into the <paramref name="rEventProp"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetMethodSemantics(System.UInt32,System.UInt32,System.UInt32@)">
            <summary>Return the semantics bits for a method and the event or property with which it is associated</summary>
            <param name="mb">Method token</param>
            <param name="tkEventProp">Event or property token</param>
            <param name="pdwSemanticsFlags">Output parameter of the semantics flags</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetClassLayout(System.UInt32,System.UInt32@,System.Int64[],System.Int32,System.Int32@,System.UInt32@)">
            <summary>Get the class layout (fixed field offsets) for a class</summary>
            <param name="td">Typedef token for the class</param>
            <param name="pdwPackSize">Output parameter for packing alignment in bytes</param>
            <param name="rFieldOffset">Array of long ints into which the field offset information will be written. Each long int is a concatanation of the offset and the token for the field for which the offset is being defined</param>
            <param name="cMax">Size of the array in <paramref name="rFieldOffset"/></param>
            <param name="pcFieldOffset">Output parameter for the actual count of fields written into <paramref name="rFieldOffset"/></param>
            <param name="pulClassSize">Output parameter for total class size</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetFieldMarshal(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the field marshalling information</summary>
            <param name="tk">Token to retrieve marshalling infomation for</param>
            <param name="ppvNativeType">Output parameter for pointer to native type signature for marshalling</param>
            <param name="pcbNativeType">Output parameter for the count of bytes for <paramref name="ppvNativeType"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetRVA(System.UInt32,System.UInt32@,System.Int32@)">
            <summary>Get the Relative Virtual Address for data associated with a token</summary>
            <param name="tk">Token to retrieve RVA infomation for</param>
            <param name="pulCodeRVA">Output parameter for the RVA</param>
            <param name="pdwImplFlags">Output parameter for the implementation flags</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetPermissionSetProps(System.UInt32,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a permission set</summary>
            <param name="pm">Permission set token</param>
            <param name="pdwAction">Output parameter for the action set mask</param>
            <param name="ppvPermission">Output parameter for the native pointer to the permission blob</param>
            <param name="pcbPermission">Output parameter for the byte count in <paramref name="ppvPermission"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetSigFromToken(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the signature blob associated with a token</summary>
            <param name="mdSig">The token to retrieve the signature from</param>
            <param name="ppvSig">Output parameter for the native pointer to the permission blob</param>
            <param name="pcbSig">Output parameter for the byte count in <paramref name="ppvSig"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetModuleRefProps(System.UInt32,System.Char[],System.Int32,System.Int32@)">
            <summary>Retrive the detail of an imported module</summary>
            <param name="mur">Module ref token</param>
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumModuleRefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate all of the module refs in this scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="rModuleRefs">Array into which the module refs are written</param>
            <param name="cMax">Size of the array <paramref name="rModuleRefs"/></param>
            <param name="pcModuleRefs">Output parameter for the actual count written into <paramref name="rModuleRefs"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetTypeSpecFromToken(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the type signature blob from a typespec token</summary>
            <param name="typespec">Typespec token</param>
            <param name="ppvSig">Output parameter for the native pointer to the signature blob</param>
            <param name="pcbSig">Output parameter for the byte count in <paramref name="ppvSig"/></param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetNameFromToken(System.UInt32,System.IntPtr@)">
            <summary>DEPRECATED: Retrieve name from token</summary>
            <param name="tk">Token to retrive name from. Must have a name</param>
            <param name="pszUtf8NamePtr">Ouput parameter to populate with a native pointer to the name in UTF8 format</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumUnresolvedMethods(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate all methods which are not yet resolved</summary>
            <remarks>See the unmanaged metadata API documentation for details</remarks>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="rMethods">Array into which the method refs are written</param>
            <param name="cMax">Size of the array <paramref name="rMethods"/></param>
            <param name="pcTokens">Output parameter for the actual count written into <paramref name="rMethods"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetUserString(System.UInt32,System.Char[],System.Int32,System.Int32@)">
            <summary>Get a string from the user heap</summary>
            <param name="stk">Token for the string</param>
            <param name="szString">Char array into which the string is written</param>
            <param name="cchString">Size of the array <paramref name="szString"/></param>
            <param name="pchString">Output parameter for the actual count of characters written into <paramref name="szString"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetPinvokeMap(System.UInt32,System.UInt32@,System.Char[],System.Int32,System.Int32@,System.UInt32@)">
            <summary>Get the extended information for a PInvoke method</summary>
            <param name="tk">PInvoke field or method token</param>
            <param name="pdwMappingFlags">Output parameter for the mapping flags</param>
            <param name="szImportName">Char buffer into which the name will be written</param>
            <param name="cchImportName">Size of the array <paramref name="szImportName"/></param>
            <param name="pchImportName">Output parameter for the actual count of characters written into <paramref name="szImportName"/></param>
            <param name="pmrImportDLL">Output parameter into which the token for the imported module is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumSignatures(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the signatures in the assembly. What a pointless method</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="rSignatures">Array into which signature tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rSignatures"/></param>
            <param name="pcSignatures">Output parameter for the actual count written into <paramref name="rSignatures"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeSpecs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the typespecs in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="rTypeSpecs">Array into which typespec tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rTypeSpecs"/></param>
            <param name="pcTypeSpecs">Output parameter for the actual count written into <paramref name="rTypeSpecs"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumUserStrings(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the user strings in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="rStrings">Array into which string tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rStrings"/></param>
            <param name="pcStrings">Output parameter for the actual count written into <paramref name="rStrings"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetParamForMethodIndex(System.UInt32,System.Int32,System.UInt32@)">
            <summary>Get the parameter token for a particular method parameter</summary>
            <param name="md">Method token</param>
            <param name="ulParamSeq">Parameter ordinal number</param>
            <param name="ppd">Output parameter into which parameter token is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumCustomAttributes(System.UIntPtr@,System.UInt32,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the custom attributes in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.EnumTypeDefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)"/></param>
            <param name="tk">Scope token or 0 (token_null) for all</param>
            <param name="tkType">Type token or 0 (token_null) for all</param>
            <param name="rCustomAttributes">Array into which attribute tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rCustomAttributes"/></param>
            <param name="pcCustomAttributes">Output parameter for the actual count written into <paramref name="rCustomAttributes"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetCustomAttributeProps(System.UInt32,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a custom attribute</summary>
            <param name="cv">Custom attribute token</param>
            <param name="ptkObj">Object token attribute is associated with</param>
            <param name="ptkType">Type token attribute is associated with</param>
            <param name="ppBlob">Output parameter into which native attribute blob pointer is written</param>
            <param name="pcbSize">Output parameter into which size of attribute blob is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.FindTypeRef(System.UInt32,System.String,System.UInt32@)">
            <summary>Resolve a type by name</summary>
            <param name="tkResolutionScope">Token defining scope to be searched</param>
            <param name="szName">Name of type to resolve</param>
            <param name="ptr">Output parameter into which typeref token is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetMemberProps(System.UInt32,System.UInt32@,System.Char[],System.Int32,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detailed properties for a member</summary>
            <param name="mb">Member token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning member</param>
            <param name="szMember">Char array into which member name will be written</param>
            <param name="cchMember">Size of the <paramref name="szMember"/> array</param>
            <param name="pchMember">Output parameter for the actual number of chars written into <paramref name="szMember"/></param>
            <param name="pdwAttr">Output parameter for member flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pulCodeRVA">Output parameter for any associated relative virtual address</param>
            <param name="pdwImplFlags">Output parameter for implementation flags</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetFieldProps(System.UInt32,System.UInt32@,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detailed properties for a field</summary>
            <param name="mb">Field token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning field</param>
            <param name="szField">Char array into which field name will be written</param>
            <param name="cchField">Size of the <paramref name="szField"/> array</param>
            <param name="pchField">Output parameter for the actual number of chars written into <paramref name="szField"/></param>
            <param name="pdwAttr">Output parameter for field flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetPropertyProps(System.UInt32,System.UInt32@,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Get the detailed properties for a property</summary>
            <param name="prop">Property token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning property</param>
            <param name="szProperty">Char array into which property name will be written</param>
            <param name="cchProperty">Size of the <paramref name="szProperty"/> array</param>
            <param name="pchProperty">Output parameter for the actual number of chars written into <paramref name="szProperty"/></param>
            <param name="pdwPropFlags">Output parameter for property flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppDefaultValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchDefaultValue">Output parameter for string size if constant value is a string</param>
            <param name="pmdSetter">Output parameter for the method token for the setter</param>
            <param name="pmdGetter">Output parameter for the method token for the getter</param>
            <param name="rmdOtherMethod">Array into which other methods tokens associated with this property are written</param>
            <param name="cMax">Size of the <paramref name="rmdOtherMethod"/> array</param>
            <param name="pcOtherMethod">Output parameter for the actual count written into the <paramref name="rmdOtherMethod"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetParamProps(System.UInt32,System.UInt32@,System.UInt32@,System.Text.StringBuilder,System.Int32,System.Int32@,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a parameter</summary>
            <param name="tk">Parameter token</param>
            <param name="pmd">Output parameter for the owning method token</param>
            <param name="pulSequence">Output parameter for the ordinal position of this parameter</param>  
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <param name="pdwAttr">Output parameter for parameter flags</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetCustomAttributeByName(System.UInt32,System.String,System.IntPtr@,System.Int32@)">
            <summary>Retrieve a custom attribute by type name</summary>
            <param name="tkObj">Object token to which the attribute is attached</param>
            <param name="szName">Name of the attribute to retrive</param>
            <param name="ppData">Output parameter into which native pointer to custom attribute data will be written</param>
            <param name="pcbData">Output parameter into which size of attribute data will be written</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.IsValidToken(System.UInt32)">
            <summary>Determine if a token is valid</summary>
            <param name="tk">Token to test for validity</param>
            <returns>A bool which is true if the token is valid</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetNestedClassProps(System.UInt32,System.UInt32@)">
            <summary>Get the containing class for a nested class</summary>
            <param name="tdNestedClass">Token for the nested class</param>
            <param name="ptdEnclosingClass">Output parameter into which the token for the enclosing class is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.GetNativeCallConvFromSig(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>Decode the native calling convention from a signature</summary>
            <param name="pvSig">A native pointer to the signature blob</param>
            <param name="cbSig">Count of bytes in the signature</param>
            <param name="pCallConv">Output parameter into which the calling convention is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport.IsGlobal(System.UInt32,System.UInt32@)">
            <summary>Test a token to see if it is global</summary>
            <param name="pd">Token to test</param>
            <param name="pbGlobal">Output parameters which is 1 if global or zero if now</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.CloseEnum(System.UIntPtr)">
            <summary>Close an enumeration of elements in the metadata</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.CountEnum(System.UIntPtr,System.Int32@)">
            <summary>Count the number of items available in an enumerations</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
            <param name="count">An output parameter which is filled with the item count</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.ResetEnum(System.UIntPtr,System.UInt32)">
            <summary>Reset an enumeration to a specific position</summary>
            <param name="hEnum">An enumeration handle returned from one of the EnumXXXX methods</param>
            <param name="ulPos">The item position to reset to</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)">
             <summary>Tokens representing typedefs from an enumeration of typedefs in the metadata scope</summary>
             <example>
             <code>
              int hEnum=0;
              int[] toks=new int[5];
              int enumCount;
              try {
                impScope.EnumTypeDefs(ref hEnum,toks,toks.Length,out enumCount);
                char[] nameBuffer=new char[2048];
                int nameLen=0;
                int superType=0;
                int typeFlags=0;
                int global=0;
                while(enumCount&gt;0) {
                  for(int I=0;I&lt;enumCount;I++) { 
                    Console.Error.Write(toks[I].ToString("X8"));
                    impScope.GetTypeDefProps(toks[I],nameBuffer,nameBuffer.Length,out nameLen,out typeFlags,out superType);
                    impScope.IsGlobal(toks[I],out global);
                    Console.Error.WriteLine(" "+new String(nameBuffer,0,nameLen)+" "+typeFlags.ToString("X8")+" "+superType.ToString("X8")+" "+global);
                    }
            
                  impScope.EnumTypeDefs(ref hEnum,toks,toks.Length,out enumCount);
                  }
                } 
              finally {
                if(hEnum!=0) impScope.CloseEnum(hEnum);
                }
             </code>
             </example>
             <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
             <param name="rTypeDefs">An array into which the typedefs are returned</param>
             <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
             <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
             <returns>The HRESULT from the COM method</returns>
             <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)"/>
             <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeRefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Tokens representing interface implementations from an enumeration in the metadata scope</summary>
            <example><see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></example>
            <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
            <param name="td">Token specifying the TypeDef whose InterfaceImpls are required</param>
            <param name="rTypeDefs">An array into which the typedefs are returned</param>
            <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
            <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
            <returns>The HRESULT from the COM method</returns>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeRefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeRefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate tokens represention type references from an enumeration in the metadata scope</summary>
            <example><see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></example>
            <param name="phEnum">Output parameter which will be populated with the enum handle or which represents the enum handle to continue enumerating from</param>
            <param name="rTypeDefs">An array into which the typedefs are returned</param>
            <param name="cMax">Maximum number of items to return, size of the <paramref name="rTypeDefs"/> array. Use CountEnum to size this.</param>
            <param name="pcTypeDefs">Actual number of items to returned in the <paramref name="rTypeDefs"/> array</param>
            <returns>The HRESULT from the COM method</returns>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)"/>
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindTypeDefByName(System.String,System.UInt32,System.UInt32@)">
            <summary>Find a typedef token by the name of the type</summary>
            <param name="szTypeDef">The name of the type</param>
            <param name="tkEnclosingClass">The enclosing class for the type or 0 (token_null)</param>
            <param name="ptd">The output parameter into which the typedef token will be written</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetScopeProps(System.Char[],System.Int32,System.Int32@,System.Guid@)">
            <summary>Get some properties from the scope - these are the module name and the module MVID unique GUID</summary>
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <param name="mvid">Guid into which the MVID is written</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetModuleFromScope(System.UInt32@)">
            <summary>Get the metadata token for the module on which this scope was opened</summary>
            <param name="pmd">The output parameter into which the module token is written</param>
            <returns>The HRESULT from the COM method</returns>      
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetTypeDefProps(System.UInt32,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.UInt32@)">
            <summary>Get the name, flags and base class of a typedef (if appropriate)</summary>
            <param name="td">Token to retrieve the properties from</param>
            <param name="szTypeDef">Char buffer into which the name will be written</param>
            <param name="cchTypeDef">Size of the buffer <paramref name="szTypeDef"/></param>
            <param name="pchTypeDef">Output parameter for the actual number of characters written into the buffer <paramref name="szTypeDef"/></param>      
            <param name="pdwTypeDefFlags">Outpu parameter for the flags from this typedef</param>
            <param name="ptkExtends">Output parameter for the base type token</param>
            <returns>The HRESULT from the COM method</returns>      
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetInterfaceImplProps(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>Get the interface implementation details</summary>
            <param name="iiImpl">Interface implementation instance token from <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="pClass">Output class token implementing interface</param>
            <param name="ptkIface">Output interface token implemented by class</param>
            <returns>The HRESULT from the COM method</returns>      
            <seealso cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumInterfaceImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetTypeRefProps(System.UInt32,System.UInt32@,System.Char[],System.Int32,System.Int32@)">
            <summary>Get the properties from a typeref</summary>
            <param name="tr">The typeref token to retrieve details from</param>
            <param name="ptkResolutionScope">Output token for the resolution scope, either a moduleref or an assemblyref</param>
            <param name="szName">Char buffer into which the name will be written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter for the actual number of characters written into the buffer <paramref name="szName"/></param>      
            <returns>The HRESULT from the COM method</returns>         
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.ResolveTypeRef(System.UInt32,System.Guid@,System.Object@,System.UInt32@)">
            <summary>Return the scope and token for a typedef corresponding to a (possibly imported) typeref</summary>
            <param name="tr">Typeref to resolve</param>
            <param name="riid">Interface type GUID for the returned interface, normally IID_IMetadataImport</param>
            <param name="ppIScope">Output object which may be cast to the interface type specified in <paramref name="riid"/></param>
            <param name="ptd">Output parameter into which the typedef token in the scope <paramref name="ppIScope"/> is written</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMembers(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the members of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMembersWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the members of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMethods(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the methods of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMethodsWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the methods of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumFields(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the fields of a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumFieldsWithName(System.UIntPtr@,System.UInt32,System.String,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate the fields of a type which match the specified name</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="szName">Name of the members to enumerate</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumParams(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the parameters of a methods</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Typedef token to enumerate members from</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMemberRefs(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Retrieve all of the member refs for a specified type within the scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="cl">Token to enumerate members from. Use 0 (token_null) for globals</param>
            <param name="rMembers">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rMembers"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMembers"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMethodImpls(System.UIntPtr@,System.UInt32,System.UInt32*,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Retrieve all of the methods implementation details</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="td">Typedef to enumerate methods implementations from</param>
            <param name="rMethodBody">Array into which the method body tokens are written</param>
            <param name="rMethodDecl">Array into which the method interface declaration tokens are written</param>
            <param name="cMax">Size of the arrays <paramref name="rMethodBody"/> and <paramref name="rMethodDecl"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rMethodBody"/> and <paramref name="rMethodDecl"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumPermissionSets(System.UIntPtr@,System.UInt32,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Retrieve all of the permission sets for a specified type within the scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="tk">Token to enumerate members from</param>
            <param name="dwActions">Mask of actions to return if non-zero</param>
            <param name="rPermission">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rPermission"/></param>
            <param name="pcTokens">Output parameter for the actual count of tokens written into <paramref name="rPermission"/></param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindMember(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a member by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindMethod(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a method by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindField(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a field by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindMemberRef(System.UInt32,System.String,System.Byte[],System.Int32,System.UInt32@)">
            <summary>Find a memberref by name</summary>
            <param name="td">Typedef to search</param>
            <param name="szName">Member name</param>
            <param name="pvSigBlob">Signature blob to filter names by</param>
            <param name="cbSigBlob">Number of bytes in <paramref name="pvSigBlob"/></param>
            <param name="pmb">Output parameter for the matched member</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetMethodProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@)">
            <summary>Retrieve the method detail for a method token</summary>
            <param name="mb">The method token to retrieve properties from</param>
            <param name="pClass">The output parameter for the token representing the class owning this method token</param>
            <param name="szMethod">Char array into which the method name is written</param>
            <param name="cchMethod">Size of the array <paramref name="szMethod"/></param>
            <param name="pchMethod">Actual count written into the array <paramref name="szMethod"/></param>
            <param name="pdwAttr">Output parameter for the method flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pulCodeRVA">Output parameter for relative virtual address in the assembly of the method's code</param>
            <param name="pdwImplFlags">Output parameter for the method implementation flags</param>
            <returns>The HRESULT from the COM method</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetMemberRefProps(System.UInt32,System.UInt32@,System.Char[],System.Int32,System.Int32@,System.IntPtr@,System.Int32@)">
            <summary>Retrieve the member detail for a memberref token</summary>
            <param name="mr">The memberref token to retrieve properties from</param>
            <param name="ptk">The output parameter for the token representing the class def or ref owning this member token</param>
            <param name="szMember">Char array into which the member name is written</param>
            <param name="cchMember">Size of the array <paramref name="szMember"/></param>
            <param name="pchMember">Actual count written into the array <paramref name="szMember"/></param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <returns>The HRESULT from the COM member</returns> 
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumProperties(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the properties on a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="td">Token to enumerate properties from</param>
            <param name="rProperties">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rProperties"/></param>
            <param name="pcProperties">Output parameter for the actual count of tokens written into <paramref name="rProperties"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumEvents(System.UIntPtr@,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate the events on a type</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="td">Token to enumerate events from</param>
            <param name="rEvents">Array into which the member tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rEvents"/></param>
            <param name="pcEvents">Output parameter for the actual count of tokens written into <paramref name="rEvents"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetEventProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Get the detail for an event</summary>
            <param name="ev">Event token</param>
            <param name="pClass">Type in which event is defined</param>
            <param name="szEvent">Char buffer into which event name is written</param>
            <param name="cchEvent">Buffer size of <paramref name="szEvent"/></param>
            <param name="pchEvent">Output parameter for the actual number of characters written into <paramref name="szEvent"/></param>
            <param name="pdwEventFlags">Output parameter for the event flags</param>
            <param name="ptkEventType">Output parameter for the event typeref token</param> 
            <param name="pmdAddOn">Output parameter for the add method token</param>
            <param name="pmdRemoveOn">Output parameter for the remove method token</param>
            <param name="pmdFire">Output parameter for the fire method token</param>
            <param name="rmdOtherMethod">Array into which other methods tokens associated with this event are written</param>
            <param name="cMax">Size of the <paramref name="rmdOtherMethod"/> array</param>
            <param name="pcOtherMethod">Output parameter for the actual count written into the <paramref name="rmdOtherMethod"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumMethodSemantics(System.UIntPtr@,System.UInt32,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Return extended method semantics information</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="mb">Methoddef token for method of interest</param>
            <param name="rEventProp">Array into which event or property with which this method is associated is written</param>
            <param name="cMax">Size of the <paramref name="rEventProp"/> array</param>
            <param name="pcEventProp">Output parameter for the actual count written into the <paramref name="rEventProp"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetMethodSemantics(System.UInt32,System.UInt32,System.UInt32@)">
            <summary>Return the semantics bits for a method and the event or property with which it is associated</summary>
            <param name="mb">Method token</param>
            <param name="tkEventProp">Event or property token</param>
            <param name="pdwSemanticsFlags">Output parameter of the semantics flags</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetClassLayout(System.UInt32,System.UInt32@,System.Int64[],System.Int32,System.Int32@,System.UInt32@)">
            <summary>Get the class layout (fixed field offsets) for a class</summary>
            <param name="td">Typedef token for the class</param>
            <param name="pdwPackSize">Output parameter for packing alignment in bytes</param>
            <param name="rFieldOffset">Array of long ints into which the field offset information will be written. Each long int is a concatanation of the offset and the token for the field for which the offset is being defined</param>
            <param name="cMax">Size of the array in <paramref name="rFieldOffset"/></param>
            <param name="pcFieldOffset">Output parameter for the actual count of fields written into <paramref name="rFieldOffset"/></param>
            <param name="pulClassSize">Output parameter for total class size</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetFieldMarshal(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the field marshalling information</summary>
            <param name="tk">Token to retrieve marshalling infomation for</param>
            <param name="ppvNativeType">Output parameter for pointer to native type signature for marshalling</param>
            <param name="pcbNativeType">Output parameter for the count of bytes for <paramref name="ppvNativeType"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetRVA(System.UInt32,System.UInt32@,System.Int32@)">
            <summary>Get the Relative Virtual Address for data associated with a token</summary>
            <param name="tk">Token to retrieve RVA infomation for</param>
            <param name="pulCodeRVA">Output parameter for the RVA</param>
            <param name="pdwImplFlags">Output parameter for the implementation flags</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetPermissionSetProps(System.UInt32,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a permission set</summary>
            <param name="pm">Permission set token</param>
            <param name="pdwAction">Output parameter for the action set mask</param>
            <param name="ppvPermission">Output parameter for the native pointer to the permission blob</param>
            <param name="pcbPermission">Output parameter for the byte count in <paramref name="ppvPermission"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetSigFromToken(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the signature blob associated with a token</summary>
            <param name="mdSig">The token to retrieve the signature from</param>
            <param name="ppvSig">Output parameter for the native pointer to the permission blob</param>
            <param name="pcbSig">Output parameter for the byte count in <paramref name="ppvSig"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetModuleRefProps(System.UInt32,System.Char[],System.Int32,System.Int32@)">
            <summary>Retrive the detail of an imported module</summary>
            <param name="mur">Module ref token</param>
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumModuleRefs(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate all of the module refs in this scope</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="rModuleRefs">Array into which the module refs are written</param>
            <param name="cMax">Size of the array <paramref name="rModuleRefs"/></param>
            <param name="pcModuleRefs">Output parameter for the actual count written into <paramref name="rModuleRefs"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetTypeSpecFromToken(System.UInt32,System.IntPtr@,System.Int32@)">
            <summary>Get the type signature blob from a typespec token</summary>
            <param name="typespec">Typespec token</param>
            <param name="ppvSig">Output parameter for the native pointer to the signature blob</param>
            <param name="pcbSig">Output parameter for the byte count in <paramref name="ppvSig"/></param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetNameFromToken(System.UInt32,System.IntPtr@)">
            <summary>DEPRECATED: Retrieve name from token</summary>
            <param name="tk">Token to retrive name from. Must have a name</param>
            <param name="pszUtf8NamePtr">Ouput parameter to populate with a native pointer to the name in UTF8 format</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumUnresolvedMethods(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate all methods which are not yet resolved</summary>
            <remarks>See the unmanaged metadata API documentation for details</remarks>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="rMethods">Array into which the method refs are written</param>
            <param name="cMax">Size of the array <paramref name="rMethods"/></param>
            <param name="pcTokens">Output parameter for the actual count written into <paramref name="rMethods"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetUserString(System.UInt32,System.Char[],System.Int32,System.Int32@)">
            <summary>Get a string from the user heap</summary>
            <param name="stk">Token for the string</param>
            <param name="szString">Char array into which the string is written</param>
            <param name="cchString">Size of the array <paramref name="szString"/></param>
            <param name="pchString">Output parameter for the actual count of characters written into <paramref name="szString"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetPinvokeMap(System.UInt32,System.UInt32@,System.Char[],System.Int32,System.Int32@,System.UInt32@)">
            <summary>Get the extended information for a PInvoke method</summary>
            <param name="tk">PInvoke field or method token</param>
            <param name="pdwMappingFlags">Output parameter for the mapping flags</param>
            <param name="szImportName">Char buffer into which the name will be written</param>
            <param name="cchImportName">Size of the array <paramref name="szImportName"/></param>
            <param name="pchImportName">Output parameter for the actual count of characters written into <paramref name="szImportName"/></param>
            <param name="pmrImportDLL">Output parameter into which the token for the imported module is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumSignatures(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the signatures in the assembly. What a pointless method</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="rSignatures">Array into which signature tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rSignatures"/></param>
            <param name="pcSignatures">Output parameter for the actual count written into <paramref name="rSignatures"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeSpecs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate over all the typespecs in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="rTypeSpecs">Array into which typespec tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rTypeSpecs"/></param>
            <param name="pcTypeSpecs">Output parameter for the actual count written into <paramref name="rTypeSpecs"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumUserStrings(System.UIntPtr@,System.UInt32[],System.Int32,System.Int32@)">
            <summary>Enumerate over all the user strings in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="rStrings">Array into which string tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rStrings"/></param>
            <param name="pcStrings">Output parameter for the actual count written into <paramref name="rStrings"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetParamForMethodIndex(System.UInt32,System.Int32,System.UInt32@)">
            <summary>Get the parameter token for a particular method parameter</summary>
            <param name="md">Method token</param>
            <param name="ulParamSeq">Parameter ordinal number</param>
            <param name="ppd">Output parameter into which parameter token is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumCustomAttributes(System.UIntPtr@,System.UInt32,System.UInt32,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Enumerate over all the custom attributes in the assembly.</summary>
            <param name="phEnum">Enumeration handle <see cref="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.EnumTypeDefs(System.UIntPtr@,System.UInt32*,System.Int32,System.Int32@)"/></param>
            <param name="tk">Scope token or 0 (token_null) for all</param>
            <param name="tkType">Type token or 0 (token_null) for all</param>
            <param name="rCustomAttributes">Array into which attribute tokens are written</param>
            <param name="cMax">Size of the array <paramref name="rCustomAttributes"/></param>
            <param name="pcCustomAttributes">Output parameter for the actual count written into <paramref name="rCustomAttributes"/></param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetCustomAttributeProps(System.UInt32,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a custom attribute</summary>
            <param name="cv">Custom attribute token</param>
            <param name="ptkObj">Object token attribute is associated with</param>
            <param name="ptkType">Type token attribute is associated with</param>
            <param name="ppBlob">Output parameter into which native attribute blob pointer is written</param>
            <param name="pcbSize">Output parameter into which size of attribute blob is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.FindTypeRef(System.UInt32,System.String,System.UInt32@)">
            <summary>Resolve a type by name</summary>
            <param name="tkResolutionScope">Token defining scope to be searched</param>
            <param name="szName">Name of type to resolve</param>
            <param name="ptr">Output parameter into which typeref token is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetMemberProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detailed properties for a member</summary>
            <param name="mb">Member token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning member</param>
            <param name="szMember">Char array into which member name will be written</param>
            <param name="cchMember">Size of the <paramref name="szMember"/> array</param>
            <param name="pchMember">Output parameter for the actual number of chars written into <paramref name="szMember"/></param>
            <param name="pdwAttr">Output parameter for member flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pulCodeRVA">Output parameter for any associated relative virtual address</param>
            <param name="pdwImplFlags">Output parameter for implementation flags</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetFieldProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detailed properties for a field</summary>
            <param name="mb">Field token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning field</param>
            <param name="szField">Char array into which field name will be written</param>
            <param name="cchField">Size of the <paramref name="szField"/> array</param>
            <param name="pchField">Output parameter for the actual number of chars written into <paramref name="szField"/></param>
            <param name="pdwAttr">Output parameter for field flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetPropertyProps(System.UInt32,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.IntPtr@,System.Int32@,System.Int32@,System.IntPtr@,System.Int32@,System.UInt32@,System.UInt32@,System.UInt32*,System.Int32,System.Int32@)">
            <summary>Get the detailed properties for a property</summary>
            <param name="prop">Property token to retrieve detail from</param>
            <param name="pClass">Output parameter for class token owning property</param>
            <param name="szProperty">Char array into which property name will be written</param>
            <param name="cchProperty">Size of the <paramref name="szProperty"/> array</param>
            <param name="pchProperty">Output parameter for the actual number of chars written into <paramref name="szProperty"/></param>
            <param name="pdwPropFlags">Output parameter for property flags</param>
            <param name="ppvSigBlob">Output parameters for the native pointer to the signature blob. Retrieve data using System.Marshal.Copy</param>
            <param name="pcbSigBlob">Output parameter for number of bytes in the signature blob</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppDefaultValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchDefaultValue">Output parameter for string size if constant value is a string</param>
            <param name="pmdSetter">Output parameter for the method token for the setter</param>
            <param name="pmdGetter">Output parameter for the method token for the getter</param>
            <param name="rmdOtherMethod">Array into which other methods tokens associated with this property are written</param>
            <param name="cMax">Size of the <paramref name="rmdOtherMethod"/> array</param>
            <param name="pcOtherMethod">Output parameter for the actual count written into the <paramref name="rmdOtherMethod"/> array</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetParamProps(System.UInt32,System.UInt32@,System.UInt32@,System.Char*,System.Int32,System.Int32@,System.UInt32@,System.UInt32@,System.IntPtr@,System.Int32@)">
            <summary>Get the detail for a parameter</summary>
            <param name="tk">Parameter token</param>
            <param name="pmd">Output parameter for the owning method token</param>
            <param name="pulSequence">Output parameter for the ordinal position of this parameter</param>  
            <param name="szName">Char buffer into which the name is written</param>
            <param name="cchName">Size of the buffer <paramref name="szName"/></param>
            <param name="pchName">Output parameter of the number of characters actually written to <paramref name="szName"/></param>
            <param name="pdwAttr">Output parameter for parameter flags</param>
            <param name="pdwCPlusTypeFlag">Output parameter for element type for any associated constant value</param>
            <param name="ppValue">Output parameter for native pointer to constant value data</param>
            <param name="pcchValue">Output parameter for string size if constant value is a string</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetCustomAttributeByName(System.UInt32,System.String,System.IntPtr@,System.Int32@)">
            <summary>Retrieve a custom attribute by type name</summary>
            <param name="tkObj">Object token to which the attribute is attached</param>
            <param name="szName">Name of the attribute to retrive</param>
            <param name="ppData">Output parameter into which native pointer to custom attribute data will be written</param>
            <param name="pcbData">Output parameter into which size of attribute data will be written</param>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.IsValidToken(System.UInt32)">
            <summary>Determine if a token is valid</summary>
            <param name="tk">Token to test for validity</param>
            <returns>A bool which is true if the token is valid</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetNestedClassProps(System.UInt32,System.UInt32@)">
            <summary>Get the containing class for a nested class</summary>
            <param name="tdNestedClass">Token for the nested class</param>
            <param name="ptdEnclosingClass">Output parameter into which the token for the enclosing class is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.GetNativeCallConvFromSig(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>Decode the native calling convention from a signature</summary>
            <param name="pvSig">A native pointer to the signature blob</param>
            <param name="cbSig">Count of bytes in the signature</param>
            <param name="pCallConv">Output parameter into which the calling convention is written</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetadataImport2.IsGlobal(System.UInt32,System.UInt32@)">
            <summary>Test a token to see if it is global</summary>
            <param name="pd">Token to test</param>
            <param name="pbGlobal">Output parameters which is 1 if global or zero if now</param>
            <returns>The HRESULT from the COM method</returns>       
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx">
            <summary>Wrapper for the IMetaDataDispenserEx COM unmanaged API</summary>
            <remarks>The methods on this class are documented in the Metadata Unmanaged API document in the SDK Tool Developers Guide</remarks> 
            <example>
            <code>
            IMetaDataDispenserEx dispenser=new MetaDataDispenserEx();
            IMetadataImport impScope=null;
            object rawScope=null;
            Guid iidImp=Constants.IID_IMetadataImport;
            dispenser.OpenScope("bytecode.exe",0,ref iidImp,out rawScope);
            impScope=(IMetadataImport)rawScope;
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.DefineScope(System.Guid@,System.UInt32,System.Guid@,System.Object@)">
            <summary>Define a new metadata scope</summary>
            <param name="rclsid">A Guid representing Constants.CLSID_CorMetaDataRuntime.ToByteArray();</param>
            <param name="flags">Always pass 0</param>
            <param name="iid">A GUID for the required interface, one of IID_IMetaDataEmit, IID_IMetadataImport, IID_IMetaDataAssemblyEmit or IID_IMetadataAssemblyImport</param>
            <param name="scope">Output parameter which will be initialised to the new scope. Should be cast to the interface specified in <paramref name="iid"/></param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.OpenScope(System.String,System.UInt32,System.Guid@,System.Object@)">
            <summary>Open a metadata scope on an existing assembly file</summary>
            <param name="file">A fully qualified file name of an assembly</param>
            <param name="flags">0 for read, 1 for write</param>
            <param name="iid">GUID for the required interface, one of IID_IMetaDataEmit, IID_IMetadataImport, IID_IMetaDataAssemblyEmit or IID_IMetadataAssemblyImport</param>
            <param name="scope">Output parameter which will be initialised to the new scope. Should be cast to the interface specified in <paramref name="iid"/></param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.OpenScopeOnMemory(System.IntPtr,System.UInt32,System.UInt32,System.Guid@,System.Object@)">
            <summary>Open a metadata scope on an existing set of metadata mapped into memory</summary>
            <param name="data">The bytes of the assembly (i.e. base address of a mapped assembly dll file)</param>
            <param name="size">Count of bytes in <paramref name="data"/></param>
            <param name="flags">0 for read, 1 for write</param>
            <param name="iid">GUID for the required interface, one of IID_IMetaDataEmit, IID_IMetadataImport, IID_IMetaDataAssemblyEmit or IID_IMetadataAssemblyImport</param>
            <param name="scope">Output parameter which will be initialised to the new scope. Should be cast to the interface specified in <paramref name="iid"/></param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.SetOption(System.Guid@,System.Object)">
            <summary>Set an option for the metadata API behaviour</summary>
            <param name="iid">GUID for the metadata option to set</param>
            <param name="optValue">Option specific variant data. Note that this object must be convertable to a variant according to the rules in the topic "Default Marshaling for Objects" in the SDK help</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.GetOption(System.Guid@,System.Object@)">
            <summary>Get an option for the metadata API behaviour</summary>
            <param name="iid">GUID for the metadata option to set</param>
            <param name="optValue">Option specific variant data. Note that this object must be convertable to a variant according to the rules in the topic "Default Marshaling for Objects" in the SDK help</param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.OpenScopeOnITypeInfo(System.Object,System.UInt32,System.Guid@,System.Object@)">
            <summary>Open a metadata scope on an object description from a COM type library (I think)</summary>
            <param name="info">A COM ITypeInfo interface pointer for a type in a type library</param>
            <param name="flags">0 for read, 1 for write</param>
            <param name="iid">GUID for the required interface, one of IID_IMetaDataEmit, IID_IMetadataImport, IID_IMetaDataAssemblyEmit or IID_IMetadataAssemblyImport</param>
            <param name="scope">Output parameter which will be initialised to the new scope. Should be cast to the interface specified in <paramref name="iid"/></param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.GetCORSystemDirectory(System.Char[],System.Int32,System.Int32@)">
            <summary>Get the system directory for the CIL Runtime</summary>
            <param name="dir">A char buffer big enough to hold the longest result</param>
            <param name="size">Size of the buffer <paramref name="dir"/></param>
            <param name="count">Number of chars written into <paramref name="dir"/> or number of required chars if larger than <paramref name="size"/></param>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.FindAssembly(System.String,System.String,System.String,System.String,System.Char[],System.Int32,System.Int32@)">
            <summary>Find the best match for an assembly using the rules from the CIL Runtime</summary>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.Fusion.IMetaDataDispenserEx.FindAssemblyModule(System.String,System.String,System.String,System.String,System.Char[],System.Int32,System.Int32@)">
            <summary>Find the best match for an assembly module using the rules from the CIL Runtime</summary>
            <returns>The HRESULT from the COM method</returns>
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.MetaDataDispenserEx">
            <summary>Alternate interface for IMetaDataDispenserEx. tlbimp.exe creates these, I don't know why so I copied it</summary>
            <remarks>The GUID may be incorrect on this interface</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.CorMetaDataDispenserExClass">
            <summary>Co class for the MetadataDispenserEx interface</summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.Constants">
            <summary>Set of constants for useful GUIDS</summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.Fusion.IMetadataTables">
            <summary>
            This API isn't big endian friendly since it indexes directly into the memory that is stored in little endian format.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IAssemblyResolver">
            <summary>
            Interface for resolving assembly names to assemblies
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(System.Reflection.AssemblyName,JetBrains.Util.FileSystemPath@)">
            <summary>
            Resolves assembly name to assembly metadata interface
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Method">
            <summary>
            Owner
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Index">
            <summary>
            Sequence number in method local variables list
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Type">
            <summary>
            Local variable type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Find usages of <paramref name="method"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Find usages of <paramref name="field"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyReader.GetMethodBody(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns method body presentation
            </summary>
            <exception cref="T:JetBrains.Metadata.Utils.PE.MetadataReaderException">Throws if method body reader failed</exception>
            <param name="method"></param>
            <returns>Method body presentation if available, null if no method implementation found</returns>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataType">
            <summary>
            Represents a type in metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataType.AssemblyQualifiedName">
            <summary>
            Gets type presentable name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataType.OptionalModifiers">
            <summary>
            Gets array of optional modifiers
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataType.RequiredModifiers">
            <summary>
            Gets array of required modifiers
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.ElementType">
            <summary>
            Gets element type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.Rank">
            <summary>
            Gets array rank
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.Sizes">
            <summary>
            Gets sizes if specified. Note that sizes might be specified not for all dimensions.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.LBounds">
            <summary>
            Gets low bounds if specified. Note that low bounds might be specified not for all dimensions.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataAssembly">
            <summary>
            Interface which is used to access metadata of an assembly
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataEntity">
            <summary>
            Base interface for all metadata entities
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataEntity.GetCustomAttributes(System.String)">
            <summary>
            Gets array of attributes having the specified fully qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataEntity.HasCustomAttribute(System.String)">
            <summary>
            Checks if an entity has a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.Assembly">
            <summary>
            Assembly where this entity is located
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.Token">
            <summary>
            Gets assemly token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.CustomAttributes">
            <summary>
            Gets array of custom attributes defined for this metadata entity
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.CustomAttributesTypeName">
            <summary>
            Gets array of custom attributes type names (much faster than getting entire custom attributes)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeInfoFromQualifiedName(System.String,System.Boolean)">
            <summary>
            Gets type info from its qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeInfoFromToken(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets type info from its token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeFromQualifiedName(System.String,System.Boolean)">
            <summary>
            Gets type from its qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetMethodFromToken(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets the method information on the token which must be a valid IsMethodDef or IsMethodRef token.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypes">
            <summary>
            Gets array of types defined in the assembly
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetExportedTypes">
            <summary>
            Collect exported types from other modules
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.CreateMethodBodyReader">
            <summary>
            Returns new method body reader
            It opens module for read and closes it upon Dispose
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.CreateUsagesFinder">
            <summary>
            Returns new usages finder
            Note: It reads module into memory upon creation
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.AssemblyName">
            <summary>
            Gets assembly name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.ReferencedAssembliesNames">
            <summary>
            Gets array of referenced assemblies' names
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.Location">
            <summary>
            Gets assembly location
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataClassType">
            <summary>
            A type which corresponds to a type or instance of a generic class
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataClassType.Type">
            <summary>
            Gets underlying metadata type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataClassType.Arguments">
            <summary>
            Gets type parameters if applicable
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute">
            <summary>
            Represents a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.UsedConstructor">
            <summary>
            Gets constructor which is used for instantiating the attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.ConstructorArguments">
            <summary>
            Gets array of values passed as arguments to the used constructor
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.InitializedFields">
            <summary>
            Gets explicitly initialized fields
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.InitializedProperties">
            <summary>
            Gets explicitly initialized properties
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataCustomAttributeFieldInitialization">
            <summary>
            Entity which stores data about initialized field of a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttributeFieldInitialization.Field">
            <summary>
            Gets initialized field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttributeFieldInitialization.Value">
            <summary>
            Gets value the field is initialized with
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataCustomAttributePropertyInitialization">
            <summary>
            Entity which stores data about initialized property of a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttributePropertyInitialization.Property">
            <summary>
            Gets initialized property
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttributePropertyInitialization.Value">
            <summary>
            Gets value the property is initialized with
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataEvent">
            <summary>
            Represents event metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Name">
            <summary>
            Gets event name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Type">
            <summary>
            Gets event type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.DeclaringType">
            <summary>
            Gets type which declares the event
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Adder">
            <summary>
            Gets adder method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Remover">
            <summary>
            Gets remover method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Raiser">
            <summary>
            Gets raiser method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.OtherMethods">
            <summary>
            Gets array of other event methods
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataField">
            <summary>
            Represents field metadata
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataField.GetLiteralValue">
            <summary>
            Gets literal field value
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Name">
            <summary>
            Gets field name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Type">
            <summary>
            Gets field type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.DeclaringType">
            <summary>
            Gets declaring type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.MarshalSpec">
            <summary>
            Gets a marshalling specification if HasMarshalSpec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Offset">
            <summary>
            Field offset in type instance. Non-negative value if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Signature">
            <summary>
            Gets the field signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsAssembly">
            <summary>
            Gets flag indicating whether the field has assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsVolatile">
            <summary>
            Gets flag indicating whether the field has volatile modifier
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsPrivate">
            <summary>
            Gets flag indicating whether the field is private
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsPublic">
            <summary>
            Gets flag indicating whether the field is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamily">
            <summary>
            Gets flag indicating whether the field has family visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the field has family-and-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the field has family-or-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsSpecialName">
            <summary>
            Gets flag indicating whether the field has special name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsStatic">
            <summary>
            Gets flag indicating whether the field is static
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsInitOnly">
            <summary>
            Gets flag indicating whether the field is readonly
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsLiteral">
            <summary>
            Gets flag indicating whether the field is literal
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.HasMarshalSpec">
            <summary>
            Gets flag indicating whether the field has associated marshaling spec
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataGenericArgument">
            <summary>
            Represents a generic type argument
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.Kind">
            <summary>
            Gets generic argument kind: whether it is owned by a type or by a method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.Name">
            <summary>
            Gets argument name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.Index">
            <summary>
            Gets generic argument index
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.TypeOwner">
            <summary>
            Gets type owner, if the parameter belongs to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.MethodOwner">
            <summary>
            Gets method owner, if the parameter belongs to a method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.TypeConstraints">
            <summary>
            Gets argument type constraints, if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgument.Attributes">
            <summary>
            Gets argument attributes
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataGenericArgumentReferenceType">
            <summary>
            A type which is unbound reference to a generic parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataGenericArgumentReferenceType.Argument">
            <summary>
            Gets referenced generic argument
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataMethod">
            <summary>
            Represents a metadata method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.Name">
            <summary>
            Gets method name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.DeclaringType">
            <summary>
            Gets declaring type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.ReturnValue">
            <summary>
            Get the return value (which is encoded as zero-index parameter)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.Parameters">
            <summary>
            Gets method parameters
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.GenericArguments">
            <summary>
            Gets array of generic arguments of this type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.ImplementedMethods">
            <summary>
            Gets array of explicitly implemented methods
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.Signature">
            <summary>
            Gets method signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.PInvokeInfo">
            <summary>
            PInvoke mapping if IsPInvokeImpl AND signature was successfully decoded
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPInvokeImpl">
            <summary>
            Gets flag indicating whether the method has PInvoke implementation
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.CodeType">
            <summary>
            Returns method implementation platform (IL, native code or runtime embedded)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsForwardRef" -->
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPreserveSig">
            <summary>
             Indicates method sig is not to be mangled to do HRESULT conversion.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsInternalCall">
            <summary>
            Method is implemented in runtime (?)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsSynchronized">
            <summary>
            Method is single threaded through the body.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.NoInlining">
            <summary>
            Method may not be inlined
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.NoOptimization">
            <summary>
            Method may not be optimized
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsAssembly">
            <summary>
            Gets flag indicating whether the method has assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPrivate">
            <summary>
            Gets flag indicating whether the method is private
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPublic">
            <summary>
            Gets flag indicating whether the method is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamily">
            <summary>
            Gets flag indicating whether the method has family visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the method has family-and-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the method has family-or-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsSpecialName">
            <summary>
            Gets flag indicating whether the method has special name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsStatic">
            <summary>
            Gets flag indicating whether the method is static
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsAbstract">
            <summary>
            Gets flag indicating whether the method is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsVirtual">
            <summary>
            Gets flag indicating whether the method is virtual
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFinal">
            <summary>
            Gets flad indicating whether the method can be overriden
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsHideBySig">
            <summary>
            Gets flag indicating whether the method hides by name and signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsNewSlot">
            <summary>
            Gets flag indicating whether the method is newslot
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsVarArg">
            <summary>
            Gets flag indicating whether the method is vararg
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsUnmanaged">
            <summary>
            Gets flag indicating whether the method is unmanaged
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataParameter">
            <summary>
            Represents a method parameter
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataParameter.GetDefaultValue">
            <summary>
            Gets default field value
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.Name">
            <summary>
            Gets parameter name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.Type">
            <summary>
            Gets parameter type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.DeclaringMethod">
            <summary>
            Gets method which declares this parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.MarshalSpec">
            <summary>
            Gets a marshalling specification if HasMarshalSpec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsIn">
            <summary>
            Gets flag indicating whether the parameter is input
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsOut">
            <summary>
            Gets flag indicating whether the parameter is output
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsParamArray">
            <summary>
            Gets flag indicating whether the parameter is parameter array
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsOptional">
            <summary>
            Gets flag indicating whether the parameter is optional
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.HasMarshalSpec">
            <summary>
            Gets flag indicating whether the parameter has associated marshaling spec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.HasDefaultValue">
            <summary>
            Gets flag indicating whether the parameter has associated default value
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataPointerType">
            <summary>
            Unmanaged pointer to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataPointerType.Type">
            <summary>
            Gets nested type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataProperty">
            <summary>
            Represents a property metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Name">
            <summary>
            Gets property name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Type">
            <summary>
            Gets property type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.DeclaringType">
            <summary>
            Gets type which declares the property
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Getter">
            <summary>
            Gets getter method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Setter">
            <summary>
            Gets setter method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.OtherAccessors">
            <summary>
            Gets all property accessors
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataReferenceType">
            <summary>
            Managed pointer to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReferenceType.Type">
            <summary>
            Gets nested type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataReturnValue">
            <summary>
            Represents a method return value (which is encoded as zero-index parameter)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.DeclaringMethod">
            <summary>
            Gets method which declares this parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.Type">
            <summary>
            Gets parameter type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataTypeInfo">
            <summary>
            Interface for accessing types metadata
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetMemberInfos">
            <summary>
            Get the names of all members (except of nested type names).
            This is fast, not decoding
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetMethods">
            <summary>
            Gets type methods
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetFields">
            <summary>
            Gets type fields
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetProperties">
            <summary>
            Gets type properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetEvents">
            <summary>
            Gets type events
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetNestedTypes">
            <summary>
            Gets nested types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.FullyQualifiedName">
            <summary>
            Gets fully qualified name of the type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Name">
            <summary>
            Gets name of the type.
            That's fully qualified name for top-level types
            and nested component for nested types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.DeclaringAssemblyName">
            <summary>
            Assembly name (if any) where this type is located
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Base">
            <summary>
            Gets base type (very usefull comment)
            </summary>
            <remarks>Returns null if there is no base type</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.DeclaringType">
            <summary>
            Gets declaring type if the type is nested type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Interfaces">
            <summary>
            Gets array of interfaces implemented by this type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GenericParameters">
            <summary>
            Gets array of generic arguments of this type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsSpecialName">
            <summary>
            Gets flag indicating whether the type has special name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsAbstract">
            <summary>
            Gets flag indicating whether the type is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsSealed">
            <summary>
            Gets flag indicating whether the type is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Layout">
            <summary>
            Fields layout type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.InteropStringFormat">
            <summary>
            Charset for pinvoke calls
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsClass">
            <summary>
            Gets flag indicating whether the type is a class type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsInterface">
            <summary>
            Gets flag indicating whether the type is an interface
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsSerializable">
            <summary>
            Gets flag indicating whether the type is serializable
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsPublic">
            <summary>
            Gets flag indicating whether the type is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNotPublic">
            <summary>
            Gets flag indicating whether the type is not public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNested">
            <summary>
            Gets flag indicating whether the type is a nested of any type (i.e. any of IsNested* is true)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedPublic">
            <summary>
            Gets flag indicating whether the type is a nested public type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedPrivate">
            <summary>
            Gets flag indicating whether the type is a nested private type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamily">
            <summary>
            Gets flag indicating whether the type is a nested family type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedAssembly">
            <summary>
            Gets flag indicating whether the type is a nested assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the type is a nested family-and-assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the type is a nested family-or-assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.PackingSize">
            <summary>
            Packing size for layout process. Positive value if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.ClassSize">
            <summary>
            Class size. Positive value if specified
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MemberInfo">
            <summary>
            Unified information about type member
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MemberInfo.Name">
            <summary>
            Name of the type member
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MemberInfo.Token">
            <summary>
            Member token
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataLoader">
            <summary>
            Manages metadata loading
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataLoader.LoadFrom(System.String,JetBrains.Metadata.Reader.API.MetadataLoader.LoadReferencedAssemblyPredicate)">
            <summary>
            Load assembly from the specified file
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataLoader.Load(System.Reflection.AssemblyName,JetBrains.Metadata.Reader.API.MetadataLoader.LoadReferencedAssemblyPredicate)">
            <summary>
            Load assembly with the specified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetFieldPresentations(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Returns field defs or refs that corresponds to <paramref name="field"/> in this assembly
            </summary>
            <returns>Array of field defs or refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetTypePresentations(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Returns type defs, refs or specs that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>Array of type defs, refs or specs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetTokenFromTypeInfo(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Find a token that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>TypeDef or TypeRef or Nil</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetMethodPresentations(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns method specs, defs or refs that corresponds to <paramref name="method"/> in this assembly
            </summary>
            <returns>Array of method specs, defs, refs tokens</returns>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.ReferencesAssemblyResolver">
            <summary>
            Searches in gac and near provided assembly. Note: ignores version redirection, probing path and so on
            </summary>
        </member>
        <member name="T:System.GAC.ASM_DISPLAY_FLAGS">
            <summary>
            <see cref="M:System.GAC.IAssemblyName.GetDisplayName(System.Text.StringBuilder,System.UInt32@,System.GAC.ASM_DISPLAY_FLAGS)"/>
            </summary>
        </member>
        <member name="T:System.GAC.ASM_NAME">
            <summary>
            The ASM_NAME enumeration property ID describes the valid names of the name-value pairs in an assembly name. 
            See the .NET Framework SDK for a description of these properties. 
            </summary>
        </member>
        <member name="T:System.GAC.IASSEMBLYCACHE_UNINSTALL_DISPOSITION">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.UninstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[],System.UInt32@)"/>
            </summary>
        </member>
        <member name="T:System.GAC.QUERYASMINFO_FLAG">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.QueryAssemblyInfo(System.UInt32,System.String,System.GAC.ASSEMBLY_INFO@)"/>
            </summary>
        </member>
        <member name="T:System.GAC.IASSEMBLYCACHE_INSTALL_FLAG">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.InstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[])"/>
            </summary>
        </member>
        <member name="T:System.GAC.CREATE_ASM_NAME_OBJ_FLAGS">
            <summary>
            The CREATE_ASM_NAME_OBJ_FLAGS enumeration contains the following values: 
            CANOF_PARSE_DISPLAY_NAME - If this flag is specified, the szAssemblyName parameter is a full assembly name and is parsed to 
            	the individual properties. If the flag is not specified, szAssemblyName is the "Name" portion of the assembly name.
            CANOF_SET_DEFAULT_VALUES - If this flag is specified, certain properties, such as processor architecture, are set to 
            	their default values.
            <see cref="M:System.GAC.AssemblyCache.CreateAssemblyNameObject(System.GAC.IAssemblyName@,System.String,System.UInt32,System.IntPtr)"/>
            </summary>
        </member>
        <member name="T:System.GAC.ASM_CACHE_FLAGS">
            <summary>
            The ASM_CACHE_FLAGS enumeration contains the following values: 
            ASM_CACHE_ZAP - Enumerates the cache of precompiled assemblies by using Ngen.exe.
            ASM_CACHE_GAC - Enumerates the GAC.
            ASM_CACHE_DOWNLOAD - Enumerates the assemblies that have been downloaded on-demand or that have been shadow-copied.
            </summary>
        </member>
        <member name="T:System.GAC.FUSION_INSTALL_REFERENCE">
            <summary>
            The FUSION_INSTALL_REFERENCE structure represents a reference that is made when an application has installed an 
            assembly in the GAC. 
            The fields of the structure are defined as follows: 
            	cbSize - The size of the structure in bytes.
            	dwFlags - Reserved, must be zero.
            	guidScheme - The entity that adds the reference.
            	szIdentifier - A unique string that identifies the application that installed the assembly.
            	szNonCannonicalData - A string that is only understood by the entity that adds the reference. 
            			The GAC only stores this string.
            Possible values for the guidScheme field can be one of the following: 
            	FUSION_REFCOUNT_MSI_GUID - The assembly is referenced by an application that has been installed by using 
            			Windows Installer. The szIdentifier field is set to MSI, and szNonCannonicalData is set to Windows Installer. 
            			This scheme must only be used by Windows Installer itself.
            	FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID - The assembly is referenced by an application that appears in Add/Remove 
            			Programs. The szIdentifier field is the token that is used to register the application with Add/Remove programs.
            	FUSION_REFCOUNT_FILEPATH_GUID - The assembly is referenced by an application that is represented by a file in 
            			the file system. The szIdentifier field is the path to this file.
            	FUSION_REFCOUNT_OPAQUE_STRING_GUID - The assembly is referenced by an application that is only represented 
            			by an opaque string. The szIdentifier is this opaque string. The GAC does not perform existence checking 
            			for opaque references when you remove this.
            </summary>
        </member>
        <member name="T:System.GAC.ASSEMBLY_INFO">
            <summary>
            The ASSEMBLY_INFO structure represents information about an assembly in the assembly cache. 
            The fields of the structure are defined as follows: 
            	cbAssemblyInfo - Size of the structure in bytes. Permits additions to the structure in future version of the .NET Framework.
            	dwAssemblyFlags - Indicates one or more of the ASSEMBLYINFO_FLAG_* bits.
            	uliAssemblySizeInKB - The size of the files that make up the assembly in kilobytes (KB).
            	pszCurrentAssemblyPathBuf - A pointer to a string buffer that holds the current path of the directory that contains the 
            			files that make up the assembly. The path must end with a zero.
            	cchBuf - Size of the buffer that the pszCurrentAssemblyPathBug field points to.
            dwAssemblyFlags can have one of the following values: 
            	ASSEMBLYINFO_FLAG__INSTALLED - Indicates that the assembly is actually installed. Always set in current version of the 
            			.NET Framework.
            	ASSEMBLYINFO_FLAG__PAYLOADRESIDENT - Never set in the current version of the .NET Framework.
            </summary>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyCache(System.GAC.IAssemblyCache@,System.UInt32)">
            <summary>
            The key entry point for reading the assembly cache.
            </summary>
            <param name="ppAsmCache">Pointer to return IAssemblyCache</param>
            <param name="dwReserved">must be 0</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyNameObject(System.GAC.IAssemblyName@,System.String,System.UInt32,System.IntPtr)">
            <summary>
            An instance of IAssemblyName is obtained by calling the CreateAssemblyNameObject API.
            </summary>
            <param name="ppAssemblyNameObj">Pointer to a memory location that receives the IAssemblyName pointer that is created.</param>
            <param name="szAssemblyName">A string representation of the assembly name or of a full assembly reference that is 
            determined by dwFlags. The string representation can be null.</param>
            <param name="dwFlags">Zero or more of the bits that are defined in the CREATE_ASM_NAME_OBJ_FLAGS enumeration.</param>
            <param name="pvReserved"> Must be null.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyEnum(System.GAC.IAssemblyEnum@,System.IntPtr,System.GAC.IAssemblyName,System.GAC.ASM_CACHE_FLAGS,System.IntPtr)">
            <summary>
            To obtain an instance of the CreateAssemblyEnum API, call the CreateAssemblyNameObject API.
            </summary>
            <param name="pEnum">Pointer to a memory location that contains the IAssemblyEnum pointer.</param>
            <param name="pUnkReserved">Must be null.</param>
            <param name="pName">An assembly name that is used to filter the enumeration. Can be null to enumerate all assemblies in the GAC.</param>
            <param name="dwFlags">Exactly one bit from the ASM_CACHE_FLAGS enumeration.</param>
            <param name="pvReserved">Must be NULL.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateInstallReferenceEnum(System.GAC.IInstallReferenceEnum@,System.GAC.IAssemblyName,System.UInt32,System.IntPtr)">
            <summary>
            To obtain an instance of the CreateInstallReferenceEnum API, call the CreateInstallReferenceEnum API.
            </summary>
            <param name="ppRefEnum">A pointer to a memory location that receives the IInstallReferenceEnum pointer.</param>
            <param name="pName">The assembly name for which the references are enumerated.</param>
            <param name="dwFlags"> Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.GetCachePath(System.GAC.ASM_CACHE_FLAGS,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            The GetCachePath API returns the storage location of the GAC. 
            </summary>
            <param name="dwCacheFlags">Exactly one of the bits defined in the ASM_CACHE_FLAGS enumeration.</param>
            <param name="pwzCachePath">Pointer to a buffer that is to receive the path of the GAC as a Unicode string.</param>
            <param name="pcchPath">Length of the pwszCachePath buffer, in Unicode characters.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyCache">
            <summary>
            Use this method as a start for the GAC API
            </summary>
            <returns>IAssemblyCache COM interface</returns>
        </member>
        <member name="M:System.GAC.AssemblyCache.GetNextAssembly(System.GAC.IAssemblyEnum,System.GAC.IAssemblyName@)">
            <summary>
            Get the next assembly name in the current enumerator or fail
            </summary>
            <param name="enumerator"></param>
            <param name="name"></param>
            <returns>0 if the enumeration is not at its end</returns>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            The assembly is referenced by an application that has been installed by using Windows Installer. 
            The szIdentifier field is set to MSI, and szNonCannonicalData is set to Windows Installer. 
            This scheme must only be used by Windows Installer itself.
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_FILEPATH_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_OPAQUE_STRING_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_MSI_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="T:System.GAC.IAssemblyCache">
            <summary>
            The IAssemblyCache interface is the top-level interface that provides access to the GAC.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyCache.UninstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[],System.UInt32@)">
            <summary>
            The IAssemblyCache::UninstallAssembly method removes a reference to an assembly from the GAC. 
            If other applications hold no other references to the assembly, the files that make up the assembly are removed from the GAC. 
            </summary>
            <param name="dwFlags">No flags defined. Must be zero.</param>
            <param name="pszAssemblyName">The name of the assembly. A zero-ended Unicode string.</param>
            <param name="pRefData">A pointer to a FUSION_INSTALL_REFERENCE structure. Although this is not recommended, 
            	this parameter can be null. The assembly is installed without an application reference, or all existing application 
            	references are gone.</param>
            <param name="pulDisposition">Pointer to an integer that indicates the action that is performed by the function.</param>
            <returns>The return values are defined as follows: 
            	S_OK - The assembly has been uninstalled.
            	S_FALSE - The operation succeeded, but the assembly was not removed from the GAC. 
            	The reason is described in pulDisposition.</returns>
            <remarks>
            NOTE: If pulDisposition is not null, pulDisposition contains one of the following values:
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED - The assembly files have been removed from the GAC.
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE - An application is using the assembly. 
            		This value is returned on Microsoft Windows 95 and Microsoft Windows 98.
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED - The assembly does not exist in the GAC.
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING - Not used.
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES - The assembly has not been removed from the GAC because 
            		another application reference exists.
            	IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND - The reference that is specified in pRefData is not found 
            		in the GAC.
            </remarks>
        </member>
        <member name="M:System.GAC.IAssemblyCache.QueryAssemblyInfo(System.UInt32,System.String,System.GAC.ASSEMBLY_INFO@)">
            <summary>
            The IAssemblyCache::QueryAssemblyInfo method retrieves information about an assembly from the GAC. 
            </summary>
            <param name="dwFlags">One of QUERYASMINFO_FLAG_VALIDATE or QUERYASMINFO_FLAG_GETSIZE: 
            	*_VALIDATE - Performs validation of the files in the GAC against the assembly manifest, including hash verification 
            		and strong name signature verification.
            	*_GETSIZE - Returns the size of all files in the assembly (disk footprint). If this is not specified, the 
            		ASSEMBLY_INFO::uliAssemblySizeInKB field is not modified.</param>
            <param name="pszAssemblyName"></param>
            <param name="pAsmInfo"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.CreateAssemblyCacheItem(System.UInt32,System.IntPtr,System.GAC.IAssemblyCacheItem@,System.String)">
            <summary>
            Undocumented
            </summary>
            <param name="dwFlags"></param>
            <param name="pvReserved"></param>
            <param name="ppAsmItem"></param>
            <param name="pszAssemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.CreateAssemblyScavenger(System.Object@)">
            <summary>
            Undocumented
            </summary>
            <param name="ppAsmScavenger"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.InstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[])">
            <summary>
            The IAssemblyCache::InstallAssembly method adds a new assembly to the GAC. The assembly must be persisted in the file 
            system and is copied to the GAC.
            </summary>
            <param name="dwFlags">At most, one of the bits of the IASSEMBLYCACHE_INSTALL_FLAG_* values can be specified: 
            	*_REFRESH - If the assembly is already installed in the GAC and the file version numbers of the assembly being 
            	installed are the same or later, the files are replaced.
            	*_FORCE_REFRESH - The files of an existing assembly are overwritten regardless of their version number.</param>
            <param name="pszManifestFilePath"> A string pointing to the dynamic-linked library (DLL) that contains the assembly manifest. 
            Other assembly files must reside in the same directory as the DLL that contains the assembly manifest.</param>
            <param name="pRefData">A pointer to a FUSION_INSTALL_REFERENCE that indicates the application on whose behalf the 
            assembly is being installed. Although this is not recommended, this parameter can be null, but this leaves the assembly 
            without any application reference.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyName">
            <summary>
            The IAssemblyName interface represents an assembly name. An assembly name includes a predetermined set of name-value pairs. 
            The assembly name is described in detail in the .NET Framework SDK.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyName.SetProperty(System.GAC.ASM_NAME,System.IntPtr,System.UInt32)">
            <summary>
            The IAssemblyName::SetProperty method adds a name-value pair to the assembly name, or, if a name-value pair 
            with the same name already exists, modifies or deletes the value of a name-value pair.
            </summary>
            <param name="propertyId">The ID that represents the name part of the name-value pair that is to be 
            added or to be modified. Valid property IDs are defined in the ASM_NAME enumeration.</param>
            <param name="pvProperty">A pointer to a buffer that contains the value of the property.</param>
            <param name="cbProperty">The length of the pvProperty buffer in bytes. If cbProperty is zero, the name-value pair 
            is removed from the assembly name.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetProperty(System.GAC.ASM_NAME,System.IntPtr,System.UInt32@)">
            <summary>
            The IAssemblyName::GetProperty method retrieves the value of a name-value pair in the assembly name that specifies the name.
            </summary>
            <param name="propertyId">The ID that represents the name of the name-value pair whose value is to be retrieved.
            Specified property IDs are defined in the ASM_NAME enumeration.</param>
            <param name="pvProperty">A pointer to a buffer that is to contain the value of the property.</param>
            <param name="pcbProperty">The length of the pvProperty buffer, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.Finalize">
            <summary>
            The IAssemblyName::Finalize method freezes an assembly name. Additional calls to IAssemblyName::SetProperty are 
            unsuccessful after this method has been called.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.GAC.IAssemblyName.GetDisplayName(System.Text.StringBuilder,System.UInt32@,System.GAC.ASM_DISPLAY_FLAGS)" -->
        <member name="M:System.GAC.IAssemblyName.BindToObject(System.Guid@,System.Object,System.Object,System.String,System.Int64,System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Undocumented
            </summary>
            <param name="refIID"></param>
            <param name="pUnkSink"></param>
            <param name="pUnkContext"></param>
            <param name="szCodeBase"></param>
            <param name="llFlags"></param>
            <param name="pvReserved"></param>
            <param name="cbReserved"></param>
            <param name="ppv"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetName(System.UInt32@,System.Text.StringBuilder)">
            <summary>
            The IAssemblyName::GetName method returns the name part of the assembly name.
            </summary>
            <param name="lpcwBuffer">Size of the pwszName buffer (on input). Length of the name (on return).</param>
            <param name="pwzName">Pointer to the buffer that is to contain the name part of the assembly name.</param>
            <returns></returns>
            <remarks>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforstrings.asp</remarks>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetVersion(System.UInt32@,System.UInt32@)">
            <summary>
            The IAssemblyName::GetVersion method returns the version part of the assembly name.
            </summary>
            <param name="pdwVersionHi">Pointer to a DWORD that contains the upper 32 bits of the version number.</param>
            <param name="pdwVersionLow">Pointer to a DWORD that contain the lower 32 bits of the version number.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.IsEqual(System.GAC.IAssemblyName,System.GAC.ASM_CMP_FLAGS)">
            <summary>
            The IAssemblyName::IsEqual method compares the assembly name to another assembly names.
            </summary>
            <param name="pName">The assembly name to compare to.</param>
            <param name="dwCmpFlags">Indicates which part of the assembly name to use in the comparison. 
            Values are one or more of the bits defined in the ASM_CMP_FLAGS enumeration.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.Clone(System.GAC.IAssemblyName@)">
            <summary>
            The IAssemblyName::Clone method creates a copy of an assembly name. 
            </summary>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyEnum">
            <summary>
            The IAssemblyEnum interface enumerates the assemblies in the GAC.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.GetNextAssembly(System.IntPtr,System.GAC.IAssemblyName@,System.UInt32)">
            <summary>
            The IAssemblyEnum::GetNextAssembly method enumerates the assemblies in the GAC. 
            </summary>
            <param name="pvReserved">Must be null.</param>
            <param name="ppName">Pointer to a memory location that is to receive the interface pointer to the assembly 
            name of the next assembly that is enumerated.</param>
            <param name="dwFlags">Must be zero.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.Reset">
            <summary>
            Undocumented. Best guess: reset the enumeration to the first assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.Clone(System.GAC.IAssemblyEnum@)">
            <summary>
            Undocumented. Create a copy of the assembly enum that is independently enumerable.
            </summary>
            <param name="ppEnum"></param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IInstallReferenceItem">
            <summary>
            The IInstallReferenceItem interface represents a reference that has been set on an assembly in the GAC. 
            Instances of IInstallReferenceIteam are returned by the IInstallReferenceEnum interface.
            </summary>
        </member>
        <member name="M:System.GAC.IInstallReferenceItem.GetReference(System.GAC.FUSION_INSTALL_REFERENCE[]@,System.UInt32,System.IntPtr)">
            <summary>
            The IInstallReferenceItem::GetReference method returns a FUSION_INSTALL_REFERENCE structure. 
            </summary>
            <param name="ppRefData">A pointer to a FUSION_INSTALL_REFERENCE structure. The memory is allocated by the GetReference 
            method and is freed when IInstallReferenceItem is released. Callers must not hold a reference to this buffer after the 
            IInstallReferenceItem object is released.</param>
            <param name="dwFlags">Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IInstallReferenceEnum">
            <summary>
            The IInstallReferenceEnum interface enumerates all references that are set on an assembly in the GAC.
            NOTE: References that belong to the assembly are locked for changes while those references are being enumerated. 
            </summary>
        </member>
        <member name="M:System.GAC.IInstallReferenceEnum.GetNextInstallReferenceItem(System.GAC.IInstallReferenceItem@,System.UInt32,System.IntPtr)">
            <summary>
            IInstallReferenceEnum::GetNextInstallReferenceItem returns the next reference information for an assembly. 
            </summary>
            <param name="ppRefItem">Pointer to a memory location that receives the IInstallReferenceItem pointer.</param>
            <param name="dwFlags">Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyCacheItem">
            <summary>
            Undocumented. Probably only for internal use.
            <see cref="M:System.GAC.IAssemblyCache.CreateAssemblyCacheItem(System.UInt32,System.IntPtr,System.GAC.IAssemblyCacheItem@,System.String)"/>
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.CreateStream(System.UInt32,System.String,System.UInt32,System.UInt32,System.Runtime.InteropServices.ComTypes.IStream@,System.Int64@)">
            <summary>
            Undocumented.
            </summary>
            <param name="dwFlags"></param>
            <param name="pszStreamName"></param>
            <param name="dwFormat"></param>
            <param name="dwFormatFlags"></param>
            <param name="ppIStream"></param>
            <param name="puliMaxSize"></param>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.Commit(System.UInt32,System.Int64@)">
            <summary>
            Undocumented.
            </summary>
            <param name="dwFlags"></param>
            <param name="pulDisposition"></param>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.AbortItem">
            <summary>
            Undocumented.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameExtensions.FindAssemblyFile(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
            Checks for the existing files and choses the assembly extension from the list, eg “exe” or “dll”.
            Throws if not found.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.AssemblyFileExtensions">
            <summary>
            A list of the valid assembly file extensions.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyResolver">
            <summary>
            Helps with looking up the referenced assemblies.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyResolver.myBaseDirs">
            <summary>
            The list of base directories to be probed for the assembly being resolved.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyResolver.myInstalledOn">
            <summary>
            The list of appdomains we've been installed onto.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Func{System.Reflection.AssemblyName,System.Boolean})">
            <summary>
            Creates the instance. Call <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Install(System.AppDomain)"/> to attach, don't forget to call <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Uninstall(System.AppDomain)"/> or <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Dispose"/> to detach on shutdown.
            </summary>
            <param name="basedirs">The list of base directories to be probed for the assembly being resolved.</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.FromAssembly(System.Reflection.Assembly,System.Func{System.Reflection.AssemblyName,System.Boolean})">
            <summary>
            Creates a resolver over the single probing directory that is the home directory of the <param name="assembly"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Install(System.AppDomain)">
            <summary>
            Starts listening for failed assembly loads on the given appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Uninstall(System.AppDomain)">
            <summary>
            Stops listening for failed assembly loads on the given appdomain.
            It is not an error to uninstall from a non-installed appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Metadata.Utils.MetadataBlobReader">
            <summary>
            Reader on bytes stream
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlobReader.ReadInt64">
            <summary>
            Read long
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlobReader.ReadTypeDefOrTypeRefEncoded">
            <summary>
            Decodes encoded type token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.#ctor(JetBrains.Util.FileSystemPath)">
            <summary>
            Ctor
            </summary>
            <param name="fileName">Name of the file</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.#ctor(System.IO.Stream)">
            <summary>
            Ctor
            </summary>
            <param name="stream">Stream with data</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.#ctor(System.Byte[])">
            <summary>
            Ctor
            </summary>
            <param name="buffer">Source array</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadBoolean(System.Int32)">
            <summary>
            Read bool value from stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadChar(System.Int32)">
            <summary>
            Read char value from stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadSingle(System.Int32)">
            <summary>
            Read float value from stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadDouble(System.Int32)">
            <summary>
            Read double value from stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadInt16(System.Int32)">
            <summary>
            Read short value from stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadSByte(System.Int32)">
            <summary>
             Read signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadUInt8(System.Int32)">
            <summary>
            Read byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadUInt16(System.Int32)">
            <summary>
            Read ushot value
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadInt32(System.Int32)">
            <summary>
            Read int value
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadUInt32(System.Int32)">
            <summary>
            Read uint
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadBytes(System.Int32,System.Int32)">
            <summary>
            Read array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataBlob.ReadTypeDefOrTypeRefEncoded(System.Int32)">
            <summary>
            Decodes encoded type token
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbFile">
            <summary>
            MS PDB debug info file reader
            </summary>
            <remarks>
            *
            * Regarding PDB files:
            * -------------------
            * They are implemented as a set of internal files (as a small file
            * system). The file is split into blocks, an internal file is made
            * of a set of blocks. Internal files are accessed through
            * numbers. For example, 
            * 1/ is the ROOT (basic information on the file)
            * 2/ is the Symbol information (global symbols, local variables...)
            * 3/ is the Type internal file (each the symbols can have type
            * information associated with it).
            *
            * Over the years, three formats existed for the PDB:
            * - ?? was rather linked to 16 bit code (our support shall be rather
            *   bad)
            * - JG: it's the signature embedded in the file header. This format
            *   has been used in MSVC 2.0 => 5.0.
            * - DS: it's the signature embedded in the file header. It's the
            *   current format supported my MS. 
            Structure of the PDB file is the following:
            1. PDBFileHeader
            [List of blocks each PDBFileHeader.BlockSize length]
            [TOC block]
            Structure of the TOC block:
            [
            DWORD dwStreams -- number of the File streams in FS
            DWORD -- size of the 0 stream
            DWORD -- size of the 1 stream
            ....
            DWORD -- size of the dwStreams - 1 stream
            ]
            Immediately After TOC block BLOCKS indexes located
            each record is the DWORD size length and contain index of the block in the FS for the Stream
            
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbHeader">
            <summary>
            PDB 7.0 file header info
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.Signature">
            <summary>
            Signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.BlockSize">
            <summary>
            Size of the file blocks
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.NumPages">
            <summary>
            Count of debug info pages
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.TocSize">
            <summary>
            Size of the Table of Contents
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.TocBlocksPage">
            <summary>
            Index of the TOC Pointers Page
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbHeader.FirstPage">
            <summary>
            First page in PDB
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbRootRecord">
            <summary>
            Root record of the PDB info
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.Pdb.PdbRootRecord.#ctor(System.IO.BinaryReader)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbRootRecord.Version">
            <summary>
            Symbolic info version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbRootRecord.TimeDateStamp">
            <summary>
            TimeStamp
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbRootRecord.SymId">
            <summary>
            Symbolic info ID
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbStream">
            <summary>
            PDB stream descriptor
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.Pdb.PdbStream.#ctor(System.UInt32,System.UInt32[])">
            <summary>
            ctor
            </summary>
            <param name="size"></param>
            <param name="blocks"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbStream.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbStream.Blocks">
            <summary>
            Stream blocks
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbStreamInfo">
            <summary>
            PDB (v 2.0) stream information stored in the Table of the Contents
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.Pdb.PdbStreamInfo.#ctor(System.IO.BinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbStreamInfo.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbSubStream">
            <summary>
            Stream for reading sub range of the underlayed stream
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Pdb.PdbToc">
            <summary>
            PDB File table of the contents
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Pdb.PdbToc.Streams">
            <summary>
            Streams existed in the PDB File
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Characteristics">
            <summary>
            COFF file characteristics
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.RELOCS_STRIPPED">
            <summary>
            Relocation info stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.EXECUTABLE_IMAGE">
            <summary>
            File is executable
            (i.e. file is neither object file nor library file,
            so there are no unresolved external references).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LINE_NUMS_STRIPPED">
            <summary>
            Line numbers stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LOCAL_SYMS_STRIPPED">
            <summary>
            Local symbols stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.AGGRESIVE_WS_TRIM">
            <summary>
            Aggressively trim working set
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LARGE_ADDRESS_AWARE">
            <summary>
            Application can handle >2gb addresses
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.BYTES_REVERSED_LO">
            <summary>
            Bytes of machine word are reversed.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.MACHINE_32BIT">
            <summary>
            32 bit word machine.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.DEBUG_STRIPPED">
            <summary>
            Debugging info stripped from file in .DBG file
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.REMOVABLE_RUN_FROM_SWAP">
            <summary>
            If Image is on removable media, copy and run from the swap file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.NET_RUN_FROM_SWAP">
            <summary>
            If Image is on Net, copy and run from the swap file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.SYSTEM">
            <summary>
            This flag is used to indicate that the file
            is a system file, such as device driver.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.DLL">
            <summary>
            This flag indicates that the file
            is a dynamic library (DLL).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.UP_SYSTEM_ONLY">
            <summary>
            File should only be run on a uniprocessor (UP) machine.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.BYTES_REVERSED_HI">
            <summary>
            Bytes of machine word are reversed.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.CLIHeader">
            <summary>
            CLI header
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.CLIHeader.#ctor(System.IO.BinaryReader,JetBrains.Metadata.Utils.PE.PEFile)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
            <param name="file"></param>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.CoffHeader">
            <summary>
            COFF header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.DataDirectory">
            <summary>
            PE section information record
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.DataDirectory.RVA">
            <summary>
            Data RVA
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.DataDirectory.Size">
            <summary>
            Data size
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory">
            <summary>
            Debug information headers in PE FILE.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase">
            <summary>
            Base class for PE directory
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase.Read(System.IO.BinaryReader,System.Int32)">
            <summary>
            Read directory
            </summary>
            <param name="rdr">reader</param>
            <param name="size">Size of directory</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Read(System.IO.BinaryReader,System.Int32)">
            <summary>
            Read directory
            </summary>
            <param name="rdr">reader</param>
            <param name="size">Size of directory</param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entries">
            <summary>
            Debug info entries located in directory
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry">
            <summary>
            Debug Directory entry
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.#ctor(System.IO.BinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="rdr">Binary reader</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.GetEntry">
            <summary>
            Returns actual info stored in the referencied PE block
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.Characteristics">
            <summary>
            Entry params
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.TimeDateStamp">
            <summary>
            Seconds from 1970
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.MajorVersion">
            <summary>
            Major version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.MinorVersion">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.Type">
            <summary>
            Debug info type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.SizeOfData">
            <summary>
            Data size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.AddressOfRawData">
            <summary>
            Address in PE file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.PointerToRawData">
            <summary>
            Pointer to the data in PE File
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugInfo">
            <summary>
            Base information about debug entry
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugInfo2">
            <summary>
            PDB 2.0 debugging info
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugInfo7">
            <summary>
            PDB 7.0 Debugging info
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugType">
            <summary>
            Summary description for DebugType.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.DosHeader">
            <summary>
            DOS file header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.ExeSignature">
            <summary>
            Image signatures
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.DOS">
            <summary>
             "MZ"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.OS2">
            <summary>
            "NE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.OS2_LE">
            <summary>
             "LE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.VXD">
            <summary>
             "LE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.NT">
            <summary>
             "PE", the complete signature is "PE\0\0"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.NT2">
            <summary>
            second part of the PE FULL sig
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.MachineId">
            <summary>
            Machine ID in the COFF header
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.UNKNOWN">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.I386">
            <summary>
            Intel 386.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.I486">
            <summary>
            Intel 486.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.PENTIUM">
            <summary>
            Intel Pentium.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.R3000_BE">
            <summary>
            MIPS 3K big-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.R3000">
            <summary>
            MIPS 3K little-endian, 0x160 big-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.R4000">
            <summary>
            MIPS 4K little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.R10000">
            <summary>
            MIPS little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.WCEMIPSV2">
            <summary>
            MIPS little-endian WCE v2
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.ALPHA">
            <summary>
            Alpha_AXP
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.SH3">
            <summary>
            SH3 little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.SH3DSP">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.SH3E">
            <summary>
            SH3E little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.SH4">
            <summary>
            SH4 little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.SH5">
            <summary>
            SH5
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.ARM">
            <summary>
            ARM Little-Endian
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:JetBrains.Metadata.Utils.PE.MachineId.THUMB" -->
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.AM33">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.POWERPC">
            <summary>
            IBM PowerPC Little-Endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.POWERPCFP">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.IA64">
            <summary>
            Intel 64
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.MIPS16">
            <summary>
            MIPS
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.ALPHA64">
            <summary>
            ALPHA64
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.MIPSFPU">
            <summary>
            MIPS
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.MIPSFPU16">
            <summary>
            MIPS
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.AXP64">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.TRICORE">
            <summary>
            Infineon
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.CEF">
            <summary>
            Common Executable Format (Windows CE).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.EBC">
            <summary>
            EFI Byte Code
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.AMD64">
            <summary>
            AMD64 (K8)
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.M32R">
            <summary>
            M32R little-endian
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.MachineId.CEE">
            <summary>
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.Signature">
            <summary>
            Netadata header signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.MajorVersion">
            <summary>
            Major version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.MinorVersion">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.Reserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.VersionString">
            <summary>
            Metadata version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.Flags">
            <summary>
            Metadat flags
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetaDataHeader.StreamHeaders">
            <summary>
            Metadata streams information
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.MetadataReaderException">
            <summary>
            Exceptions raised during module IL reading
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message">Exception reason</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message">Exception reason</param>
            <param name="innerException">Inner exception</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Special ctor for deserialization
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptHeaderSize">
            <summary>
            Standard HT optional header sizes
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_ROM_OPTIONAL_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_STD_OPTIONAL_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_NT_OPTIONAL32_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_NT_OPTIONAL64_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptionalNtHeader32">
            <summary>
            NT header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptionalNtHeader64">
            <summary>
            NT header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PEDictionaryEntry">
            <summary>
            PE File dictionary entry
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PEFile">
            <summary>
            Portable Executable file
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.#ctor(System.IO.BinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader">PE file native image reader</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.GetDirectory(System.Int32)">
            <summary>
            Read directory from PE File
            </summary>
            <param name="directoryId"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.RvaToVa(System.UInt32)">
            <summary>
            Translate Relative Virtual Address (RVA) to the actual Virtual Address (VA)
            </summary>
            <param name="rva">RVA to translate</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.CreateDictionary(System.Int32,System.Int32)">
            <summary>
            Create PE directory according its Index
            </summary>
            <param name="directoryId">Directory index</param>
            <param name="dirSize">Size of directory</param>
            <returns>Craeted object or null if:
            <list type="bullet">
            <item>
            	<code>Directory type not implemented yet</code>
            </item>
            <item>
            	<code>Passed Size of directory less then required</code>
            </item>
            <item>
            	<code>Unknown directory index passsed</code>
            </item>
            </list>
            </returns>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.DOSheader">
            <summary>
            PE File DOS stub header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.COFFheader">
            <summary>
            PE File COFF header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.PEheader">
            <summary>
            PE File PE header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.NTheader">
            <summary>
            PE File Optional NT header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.Entries">
            <summary>
            PE File directory infos
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.Sections">
            <summary>
            PE file sections dictionary
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.CLIHeader">
            <summary>
            PE File CLI data header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.MetadataHeader">
            <summary>
            CLI Metadata Header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PEHeader">
            <summary>
            PE file section header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PESignature">
            <summary>
            PE Header magic numbers
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.PESignature.PE_32BIT">
            <summary>
            PE Is 32 bit executable
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.PESignature.PE_64BIT">
            <summary>
            PE is 64 bit executable
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.SectionHeader">
            <summary>
            PE File section header
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.StreamHeader">
            <summary>
            Metadata stream information
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.StreamHeader.#ctor(System.IO.BinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Offset">
            <summary>
            Stream offset in PE file from metadata header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Name">
            <summary>
            Stream name
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Subsystem">
            <summary>
            COFF header subsystem entry meanings
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.UNKNOWN">
            <summary>
            Unknown subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.NATIVE">
            <summary>
            Image doesn't require a subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_GUI">
            <summary>
            Image runs in the Windows GUI subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_CUI">
            <summary>
            Image runs in the Windows character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.OS2_CUI">
            <summary>
            Image runs in the OS/2 character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.POSIX_CUI">
            <summary>
             Image runs in the Posix character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.NATIVE_WINDOWS">
            <summary>
            Image is a native Win9x driver.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_CE_GUI">
            <summary>
            Image runs in the Windows CE subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_APPLICATION">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_BOOT_SERVICE_DRIVER">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_RUNTIME_DRIVER">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_ROM">
            <summary>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.XBOX">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message">Error Message</param>
            <param name="exInner">Exception that cause PE loading error</param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.NameToken.Value">
            <summary>
            Token Value
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.NameToken.Range">
            <summary>
            Token Range
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Metadata.Utils.TypeName.Parser" -->
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.START">
            <summary>
            Start state
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.AQN">
            <summary>
            Assembly qualified name
            </summary>
            <returns></returns>
            <remarks>
            /* empty */
            FULLNAME ',' ASSEMSPEC
            FULLNAME
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.ASSEMSPEC">
            <summary>
            Assembly specification
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.FULLNAME">
            <summary>
            Type fullName
            </summary>
            <returns></returns>
            <remarks>
            NAME GENPARAMS QUALIFIER
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.GENPARAMS">
            <summary>
            Generic parameters
            </summary>
            <returns></returns>
            <remarks>
            *empty*
            '[' GENARGS ']'
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.GENARGS">
            <summary>
            Generic argument
            </summary>
            <returns></returns>
            <remarks>
            GENARG
            GENARG ',' GENARGS
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.EAQN">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            '[' EAQN ']'
            FULLNAME
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Metadata.Utils.TypeName.Parser.QUALIFIER" -->
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.ARRAY">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            '[' RANK ']'
            '[' '*' ']'
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.RANK(System.UInt32@)">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            *empty*
            ',' RANK
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.NAME">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            id
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.Parser.TypeName">
            <summary>
            Parsing result;
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.Parser.ParsedName.ElementType">
            <summary>
            Name of the underlaying type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.AssemblySerializer.SerializeAssembly(JetBrains.Metadata.Reader.API.IMetadataAssembly,System.Predicate{JetBrains.Metadata.Reader.API.IMetadataEntity})">
            <summary>
            
            </summary>
            <param name="assembly"></param>
            <param name="filter">coudl be used for filter private members</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Metadata.AssemblySerializer.Document">
            <summary>
            get document where serialisation info located
            </summary>
        </member>
    </members>
</doc>
